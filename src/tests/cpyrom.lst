XAS99 CROSS-ASSEMBLER   VERSION 1.7.0
**** **** ****     > cpyrom.asm.578
0001               ***************************************************************
0002               * This file: cpyrom.asm             ; Version 180314.1722
0003               ********@*****@*********************@**************************
0004                       save  >6000,>7fff
0005                       aorg  >6000
0006               *--------------------------------------------------------------
0007               * Skip unused spectra2 code modules for reducing code size
0008               *--------------------------------------------------------------
0009      0001     debug                  equ  1       ; 0|1  1=Debug
0010      0001     skip_rom_bankswitch    equ  1       ; Skip ROM bankswitching support
0011               *skip_grom_support      equ  1       ; Skip GROM support functions
0012      0001     skip_f18a_support      equ  1       ; Skip f18a support
0013      0001     skip_vdp_hchar         equ  1       : Skip hchar, xchar
0014      0001     skip_vdp_vchar         equ  1       ; Skip vchar, xvchar
0015      0001     skip_vdp_boxes         equ  1       ; Skip filbox, putbox
0016      0001     skip_vdp_hexsupport    equ  1       ; Skip mkhex, puthex
0017      0001     skip_vdp_bitmap        equ  1       ; Skip bitmap functions
0018      0001     skip_vdp_viewport      equ  1       ; Skip viewport functions
0019      0001     skip_keyboard_real     equ  1       ; Skip real keyboard support
0020      0001     skip_random_generator  equ  1       ; Skip random functions
0021               *--------------------------------------------------------------
0022               * Cartridge header
0023               *--------------------------------------------------------------
0024 6000 AA01     grmhdr  byte  >aa,1,1,0,0,0
     6002 0100 
     6004 0000 
0025 6006 6010             data  prog0
0026 6008 0000             byte  0,0,0,0,0,0,0,0
     600A 0000 
     600C 0000 
     600E 0000 
0027 6010 0000     prog0   data  0                     ; No more items following
0028 6012 67C2             data  runlib
0029               *--------------------------------------------------------------
0031 6014 1343             byte  8+11
0032 6015 ....             text  'COPY ROM 180314.1722'
0037               *--------------------------------------------------------------
0038               * Include required files
0039               *--------------------------------------------------------------
0040                       copy  "/mnt/d/tifun/asm/spectra2/runlib.asm"
**** **** ****     > runlib.asm
0001               *******************************************************************************
0002               *              ___  ____  ____  ___  ____  ____    __    ___
0003               *             / __)(  _ \( ___)/ __)(_  _)(  _ \  /__\  (__ \
0004               *             \__ \ )___/ )__)( (__   )(   )   / /(__)\  / _/
0005               *             (___/(__)  (____)\___) (__) (_)\_)(__)(__)(____)
0006               *
0007               *                 TMS9900 Monitor & Arcade Game Library
0008               *                                for
0009               *                   the Texas Instruments TI-99/4A
0010               *
0011               *                    2010-2018 by Filip Van Vooren
0012               *
0013               *              https://github.com/FilipVanVooren/spectra2.git
0014               *******************************************************************************
0015               * Credits
0016               *     1) Speech code based on version of Mark Wills
0017               *     2) Number conversion based on work of Mathew Hagerty
0018               *     3) Bold font style based on work of sometimes99er
0019               *******************************************************************************
0020               * This file: runlib.a99
0021               *******************************************************************************
0022               * v1.2    2018/03   Work-in-Progress
0023               *         New       Use constants embedded in OS ROM for reduced code size and
0024               *                   faster (16 bit) memory access.
0025               *         New       Introduced equates for skipping subroutines, allowing
0026               *                   you to reduce code size.
0027               *         Change    Repurpose bit 12 in CONFIG register from "keyboard mode" to
0028               *                   "VDP9918 sprite collision" detected.
0029               *                   This is a crucial change.
0030               *                   Bit 12 in CONFIG is set if C bit in VDP status register is
0031               *                   on. The important thing is that bit 12 is latched even
0032               *                   if C bit in VDP status register is reset (due to reading
0033               *                   VDP status register). You need to clear bit 12 manually
0034               *                   in your sprite collision routine.
0035               *         Change    Removed TI-99/4 check upon initialisation for saving
0036               *                   on code size/GROM support..
0037               *         New       Start breaking the monolith, use of submodules that can
0038               *                   be included when needed only. Major refactoring
0039               *         New       Added CLHOOK broutine
0040               *         Bug-fix   Fixed low-level VDP routines because of wrong VDP bits set.
0041               *         Change    Removed use of config bit 1 in MKHEX subroutine and
0042               *                   got rid of multiple colors possibility.
0043               *         Change    Removed OS v2.2 check (config bit 10) and repurpose bit 10.
0044               *                   Check if speech synthesizer present upon startup.
0045               *         New       Check if F18A present upon startup (config bit 1)
0046               *         Change    Repurpose bit 1 in CONFIG register from "subroutine state
0047               *                   flag 1" to "F18A present flag"
0048               *         Change    Converted source from upper case to lower case
0049               *         New       F18A support routines (detect, 80 cols, ...)
0050               *         Bug-fix   Removed 6 years-old bug!
0051               *                   Overflow in calculation of X in YX2PNT routine
0052               *                   resulted in wrong VDP target address.
0053               *------------------------------------------------------------------------------
0054               * v1.1    2011/05   This version was never officially released
0055               *                   but contains many changes and some new functions.
0056               *
0057               *         Bug-fix   by TREV2005. Fixed YX2PYX register issue
0058               *         Change    Introduced memory location @WCOLMN and rewrote YX2PNT
0059               *                   for using MPY instruction.
0060               *                   Adjusted format of video mode table to include number
0061               *                   of columns per row.
0062               *                   VIDTAB subroutine adjusted as well.
0063               *         Change    Removed subroutine GTCLMN. The functionality is replaced
0064               *                   by the @WCOLMN memory location.
0065               *         New       Added subroutine SCRDIM for setting base and
0066               *                   width of a virtual screen.
0067               *         Change    Introduced memory locations WAUX1,WAUX2,WAUX3.
0068               *         Change    PUTBOX completely rewritten, now supports repeating
0069               *                   vertically and/or horizontally.
0070               *                   This is how its supposed to work from day one..
0071               *                   WARNING PUTBOX is not compatible with V1.
0072               *                   width & height swapped in P1.
0073               *         Change    Removed memory location WSEED.
0074               *                   On startup value is in WAUX1.
0075               *                   Added parameter P1 to RND subroutine (address random seed)
0076               *         Change    Modified FILBOX subroutine. Width and height swapped
0077               *                   in P1 so that it's the same as for PUTBOX subroutine.
0078               *         New       Added VIEW subroutine. This is a viewport into
0079               *                   a virtual screen.
0080               *         New       Added RLE2V subroutine.
0081               *                   Decompress RLE (Run Length Encoded data) to VRAM.
0082               *------------------------------------------------------------------------------
0083               * v1.0    2011/02   Initial version
0084               *******************************************************************************
0085               * Use following equates for reducing code size:
0086               *
0087               * skip_rom_bankswitch    equ  1       ; Skip support for ROM bankswitching
0088               * skip_grom_support      equ  1       ; Skip GROM spport functions
0089               * skip_f18a_support      equ  1       ; Skip f18a support
0090               * skip_vdp_hchar         equ  1       ; Skip hchar, xchar
0091               * skip_vdp_vchar         equ  1       ; Skip vchar, xvchar
0092               * skip_vdp_boxes         equ  1       ; Skip filbox, putbox
0093               * skip_vdp_hexsupport    equ  1       ; Skip mkhex, puthex
0094               * skip_vdp_bitmap        equ  1       ; Skip bitmap functions
0095               * skip_vdp_viewport      equ  1       ; Skip viewport functions
0096               * skip_keyboard_real     equ  1       ; Skip real keyboard support
0097               * skip_random_generator  equ  1       ; Skip random functions
0098               * use_osrom_constants    equ  1       ; Take constants from TI-99/4A OS ROM
0099               *******************************************************************************
0100               
0101               
0102               
0103               *//////////////////////////////////////////////////////////////
0104               *                       RUNLIB MEMORY SETUP
0105               *//////////////////////////////////////////////////////////////
0106               
0107               ***************************************************************
0108               * >8300 - >8341     Scratchpad memory layout (66 bytes)
0109               ********@*****@*********************@**************************
0110      8300     ws1     equ   >8300                 ; 32 - Primary workspace
0111      8320     mcloop  equ   >8320                 ; 08 - Machine code for loop & speech
0112      8328     wbase   equ   >8328                 ; 02 - PNT base address
0113      832A     wyx     equ   >832a                 ; 02 - Cursor YX position
0114      832C     wtitab  equ   >832c                 ; 02 - Timers: Address of timer table
0115      832E     wtiusr  equ   >832e                 ; 02 - Timers: Address of user hook
0116      8330     wtitmp  equ   >8330                 ; 02 - Timers: Internal use
0117      8332     wvrtkb  equ   >8332                 ; 02 - Virtual keyboard flags
0118      8334     wsdlst  equ   >8334                 ; 02 - Sound player: Tune address
0119      8336     wsdtmp  equ   >8336                 ; 02 - Sound player: Temporary use
0120      8338     wspeak  equ   >8338                 ; 02 - Speech player: Address of LPC data
0121      833A     wcolmn  equ   >833a                 ; 02 - Screen size, columns per row
0122      833C     waux1   equ   >833c                 ; 02 - Temporary storage 1
0123      833E     waux2   equ   >833e                 ; 02 - Temporary storage 2
0124      8340     waux3   equ   >8340                 ; 02 - Temporary storage 3
0125               ***************************************************************
0126      832A     by      equ   wyx                   ;      Cursor Y position
0127      832B     bx      equ   wyx+1                 ;      Cursor X position
0128      8322     mcsprd  equ   mcloop+2              ;      Speech read routine
0129               ***************************************************************
0130               * Register usage
0131               * R0-R3   General purpose registers
0132               * R4-R8   Temporary registers
0133               * R9      Stack pointer
0134               * R10     Highest slot in use + Timer counter
0135               * R11     Subroutine return address
0136               * R12     Configuration register
0137               * R13     Copy of VDP status byte and counter for sound player
0138               * R14     Copy of VDP register #0 and VDP register #1 bytes
0139               * R15     VDP read/write address
0140               ***************************************************************
0141               * Workspace and register equates
0142               ********@*****@*********************@**************************
0143      0000     r0      equ   0
0144      0001     r1      equ   1
0145      0002     r2      equ   2
0146      0003     r3      equ   3
0147      0004     r4      equ   4
0148      0005     r5      equ   5
0149      0006     r6      equ   6
0150      0007     r7      equ   7
0151      0008     r8      equ   8
0152      0009     r9      equ   9
0153      000A     r10     equ   10
0154      000B     r11     equ   11
0155      000C     r12     equ   12
0156      000D     r13     equ   13
0157      000E     r14     equ   14
0158      000F     r15     equ   15
0159      8300     r0hb    equ   ws1                   ; HI byte R0
0160      8301     r0lb    equ   ws1+1                 ; LO byte R0
0161      8302     r1hb    equ   ws1+2                 ; HI byte R1
0162      8303     r1lb    equ   ws1+3                 ; LO byte R1
0163      8304     r2hb    equ   ws1+4                 ; HI byte R2
0164      8305     r2lb    equ   ws1+5                 ; LO byte R2
0165      8306     r3hb    equ   ws1+6                 ; HI byte R3
0166      8307     r3lb    equ   ws1+7                 ; LO byte R3
0167      8308     r4hb    equ   ws1+8                 ; HI byte R4
0168      8309     r4lb    equ   ws1+9                 ; LO byte R4
0169      830A     r5hb    equ   ws1+10                ; HI byte R5
0170      830B     r5lb    equ   ws1+11                ; LO byte R5
0171      830C     r6hb    equ   ws1+12                ; HI byte R6
0172      830D     r6lb    equ   ws1+13                ; LO byte R6
0173      830E     r7hb    equ   ws1+14                ; HI byte R7
0174      830F     r7lb    equ   ws1+15                ; LO byte R7
0175      8310     r8hb    equ   ws1+16                ; HI byte R8
0176      8311     r8lb    equ   ws1+17                ; LO byte R8
0177      8312     r9hb    equ   ws1+18                ; HI byte R9
0178      8313     r9lb    equ   ws1+19                ; LO byte R9
0179      8314     r10hb   equ   ws1+20                ; HI byte R10
0180      8315     r10lb   equ   ws1+21                ; LO byte R10
0181      8316     r11hb   equ   ws1+22                ; HI byte R11
0182      8317     r11lb   equ   ws1+23                ; LO byte R11
0183      8318     r12hb   equ   ws1+24                ; HI byte R12
0184      8319     r12lb   equ   ws1+25                ; LO byte R12
0185      831A     r13hb   equ   ws1+26                ; HI byte R13
0186      831B     r13lb   equ   ws1+27                ; LO byte R13
0187      831C     r14hb   equ   ws1+28                ; HI byte R14
0188      831D     r14lb   equ   ws1+29                ; LO byte R14
0189      831E     r15hb   equ   ws1+30                ; HI byte R15
0190      831F     r15lb   equ   ws1+31                ; LO byte R15
0191      0004     tmp0    equ   r4                    ; Temp register 0
0192      0005     tmp1    equ   r5                    ; Temp register 1
0193      0006     tmp2    equ   r6                    ; Temp register 2
0194      0007     tmp3    equ   r7                    ; Temp register 3
0195      0008     tmp4    equ   r8                    ; Temp register 4
0196      0009     tmp5    equ   r9                    ; Temp register 5
0197      000F     tmp6    equ   r15                   ; Temp register 6
0198      8308     tmp0hb  equ   ws1+8                 ; HI byte R4
0199      8309     tmp0lb  equ   ws1+9                 ; LO byte R4
0200      830A     tmp1hb  equ   ws1+10                ; HI byte R5
0201      830B     tmp1lb  equ   ws1+11                ; LO byte R5
0202      830C     tmp2hb  equ   ws1+12                ; HI byte R6
0203      830D     tmp2lb  equ   ws1+13                ; LO byte R6
0204      830E     tmp3hb  equ   ws1+14                ; HI byte R7
0205      830F     tmp3lb  equ   ws1+15                ; LO byte R7
0206      8310     tmp4hb  equ   ws1+16                ; HI byte R8
0207      8311     tmp4lb  equ   ws1+17                ; LO byte R8
0208      8310     tmp5hb  equ   ws1+16                ; HI byte R8
0209      8311     tmp5lb  equ   ws1+17                ; LO byte R8
0210      831E     tmp6hb  equ   ws1+30                ; HI byte R15
0211      831F     tmp6lb  equ   ws1+31                ; LO byte R15
0212               ***************************************************************
0213               * Equates for VDP, GROM, SOUND, SPEECH ports
0214               ********@*****@*********************@**************************
0215      8400     sound   equ   >8400                 ; Sound generator address
0216      8800     vdpr    equ   >8800                 ; VDP read data window address
0217      8C00     vdpw    equ   >8c00                 ; VDP write data window address
0218      8802     vdps    equ   >8802                 ; VDP status register
0219      8C02     vdpa    equ   >8c02                 ; VDP address register
0220      9C02     grmwa   equ   >9c02                 ; GROM set write address
0221      9802     grmra   equ   >9802                 ; GROM set read address
0222      9800     grmrd   equ   >9800                 ; GROM read byte
0223      9C00     grmwd   equ   >9c00                 ; GROM write byte
0224      9000     spchrd  equ   >9000                 ; Address of speech synth Read Data Register
0225      9400     spchwt  equ   >9400                 ; Address of speech synth Write Data Register
0226               ***************************************************************
0227               * Equates for registers
0228               ********@*****@*********************@**************************
0229      0009     stack   equ   r9                    ; Stack pointer
0230      8314     btihi   equ   ws1+20                ; Highest slot in use (HI byte R10)
0231      000C     config  equ   r12                   ; SPECTRA configuration register
0232      831A     bvdpst  equ   ws1+26                ; Copy of VDP status register (HI byte R13)
0233      000E     vdpr01  equ   r14                   ; Copy of VDP#0 and VDP#1 bytes
0234      831C     vdpr0   equ   ws1+28                ; High byte of R14. Is VDP#0 byte
0235      831D     vdpr1   equ   ws1+29                ; Low byte  of R14. Is VDP#1 byte
0236      000F     vdprw   equ   r15                   ; Contains VDP read/write address
0237               ***************************************************************
0238               * Equates for memory locations
0239               ********@*****@*********************@**************************
0240      832E     wramf   equ   >832e                 ; Memory location F
0241      8338     wramk   equ   >8338                 ; Memory location K
0242      833A     wraml   equ   >833a                 ; Memory location L
0243               ***************************************************************
0244               * The config register equates
0245               *--------------------------------------------------------------
0246               * Configuration flags
0247               * ===================
0248               *
0249               * ; 15  Sound player: tune source       1=ROM/RAM      0=VDP MEMORY
0250               * ; 14  Sound player: repeat tune       1=yes          0=no
0251               * ; 13  Sound player: enabled           1=yes          0=no (or pause)
0252               * ; 12  VDP9918 sprite collision?       1=yes          0=no
0253               * ; 11  Keyboard: ANY key pressed       1=yes          0=no
0254               * ; 10  Speech Synthesizer present      1=yes          0=no
0255               * ; 09  Timer: Kernel thread enabled    1=yes          0=no
0256               * ; 08  Timer: Block kernel thread      1=yes          0=no
0257               * ; 07  Timer: User hook enabled        1=yes          0=no
0258               * ; 06  Timer: Block user hook          1=yes          0=no
0259               * ; 05  speech player: external voice   1=yes          0=no
0260               * ; 04  Speech player: busy             1=yes          0=no
0261               * ; 03  Speech player: enabled          1=yes          0=no
0262               * ; 02  VDP9918 PAL version             1=yes(50)      0=no(60)
0263               * ; 01  F18A present                    1=on           0=off
0264               * ; 00  Subroutine state flag           1=on           0=off
0265               ********@*****@*********************@**************************
0266      2000     palon   equ   >2000                 ; bit 2=1   (VDP9918 PAL version)
0267      0100     enusr   equ   >0100                 ; bit 7=1   (Enable user hook)
0268      0040     enknl   equ   >0040                 ; bit 9=1   (Enable kernel thread)
0269      0020     tms5200 equ   >0020                 ; bit 10=1  (Speech Synthesizer present)
0270               ***************************************************************
0271               * Subroutine parameter equates
0272               ***************************************************************
0273      FFFF     eol     equ   >ffff                 ; End-Of-List
0274      FFFF     nofont  equ   >ffff                 ; Skip loading font in RUNLIB
0275      0000     norep   equ   0                     ; PUTBOX > Value for P3. Don't repeat box
0276      3030     num1    equ   >3030                 ; MKNUM  > ASCII 0-9, leading 0's
0277      3020     num2    equ   >3020                 ; MKNUM  > ASCII 0-9, leading spaces
0278      0007     sdopt1  equ   7                     ; SDPLAY > 111 (Player on, repeat, tune in CPU memory)
0279      0005     sdopt2  equ   5                     ; SDPLAY > 101 (Player on, no repeat, tune in CPU memory)
0280      0006     sdopt3  equ   6                     ; SDPLAY > 110 (Player on, repeat, tune in VRAM)
0281      0004     sdopt4  equ   4                     ; SDPLAY > 100 (Player on, no repeat, tune in VRAM)
0282      0000     fnopt1  equ   >0000                 ; LDFNT  > Load TI title screen font
0283      0006     fnopt2  equ   >0006                 ; LDFNT  > Load upper case font
0284      000C     fnopt3  equ   >000c                 ; LDFNT  > Load upper/lower case font
0285      0012     fnopt4  equ   >0012                 ; LDFNT  > Load lower case font
0286      8000     fnopt5  equ   >8000                 ; LDFNT  > Load TI title screen font  & bold
0287      8006     fnopt6  equ   >8006                 ; LDFNT  > Load upper case font       & bold
0288      800C     fnopt7  equ   >800c                 ; LDFNT  > Load upper/lower case font & bold
0289      8012     fnopt8  equ   >8012                 ; LDFNT  > Load lower case font       & bold
0290               *--------------------------------------------------------------
0291               *   Speech player
0292               *--------------------------------------------------------------
0293      1400     spopt1  equ   >1400                 ; 0001010000000000 (Player on, external voice)
0294      1000     spopt2  equ   >1000                 ; 0001000000000000 (Player on, resident voice)
0295      0060     talkon  equ   >60                   ; 'start talking' command code for speech synth
0296      00FF     talkof  equ   >ff                   ; 'stop talking' command code for speech synth
0297      6000     spkon   equ   >6000                 ; 'start talking' command code for speech synth
0298      FF00     spkoff  equ   >ff00                 ; 'stop talking' command code for speech synth
0299               ***************************************************************
0300               * Virtual keyboard equates
0301               ***************************************************************
0302               * bit  0: ALPHA LOCK down             0=no  1=yes
0303               * bit  1: ENTER                       0=no  1=yes
0304               * bit  2: REDO                        0=no  1=yes
0305               * bit  3: BACK                        0=no  1=yes
0306               * bit  4: Pause                       0=no  1=yes
0307               * bit  5: *free*                      0=no  1=yes
0308               * bit  6: P1 Left                     0=no  1=yes
0309               * bit  7: P1 Right                    0=no  1=yes
0310               * bit  8: P1 Up                       0=no  1=yes
0311               * bit  9: P1 Down                     0=no  1=yes
0312               * bit 10: P1 Space / fire / Q         0=no  1=yes
0313               * bit 11: P2 Left                     0=no  1=yes
0314               * bit 12: P2 Right                    0=no  1=yes
0315               * bit 13: P2 Up                       0=no  1=yes
0316               * bit 14: P2 Down                     0=no  1=yes
0317               * bit 15: P2 Space / fire / Q         0=no  1=yes
0318               ***************************************************************
0319      8000     kalpha  equ   >8000                 ; Virtual key alpha lock
0320      4000     kenter  equ   >4000                 ; Virtual key enter
0321      2000     kredo   equ   >2000                 ; Virtual key REDO
0322      1000     kback   equ   >1000                 ; Virtual key BACK
0323      0800     kpause  equ   >0800                 ; Virtual key pause
0324      0400     kfree   equ   >0400                 ; ***NOT USED YET***
0325               *--------------------------------------------------------------
0326               * Keyboard Player 1
0327               *--------------------------------------------------------------
0328      0280     k1uplf  equ   >0280                 ; Virtual key up   + left
0329      0180     k1uprg  equ   >0180                 ; Virtual key up   + right
0330      0240     k1dnlf  equ   >0240                 ; Virtual key down + left
0331      0140     k1dnrg  equ   >0140                 ; Virtual key down + right
0332      0200     k1lf    equ   >0200                 ; Virtual key left
0333      0100     k1rg    equ   >0100                 ; Virtual key right
0334      0080     k1up    equ   >0080                 ; Virtual key up
0335      0040     k1dn    equ   >0040                 ; Virtual key down
0336      0020     k1fire  equ   >0020                 ; Virtual key fire
0337               *--------------------------------------------------------------
0338               * Keyboard Player 2
0339               *--------------------------------------------------------------
0340      0014     k2uplf  equ   >0014                 ; Virtual key up   + left
0341      000C     k2uprg  equ   >000c                 ; Virtual key up   + right
0342      0012     k2dnlf  equ   >0012                 ; Virtual key down + left
0343      000A     k2dnrg  equ   >000a                 ; Virtual key down + right
0344      0010     k2lf    equ   >0010                 ; Virtual key left
0345      0008     k2rg    equ   >0008                 ; Virtual key right
0346      0004     k2up    equ   >0004                 ; Virtual key up
0347      0002     k2dn    equ   >0002                 ; Virtual key down
0348      0001     k2fire  equ   >0001                 ; Virtual key fire
0349                       even
0350               
0351               
0352               ***************************************************************
0353               * Bank switch routine
0354               ***************************************************************
0358               
0359               
0360               ***************************************************************
0361               *                      Some constants
0362               ********@*****@*********************@**************************
0393 602A 8000     wbit0   data  >8000                 ; Binary 1000000000000000
0394 602C 4000     wbit1   data  >4000                 ; Binary 0100000000000000
0395 602E 2000     wbit2   data  >2000                 ; Binary 0010000000000000
0396 6030 1000     wbit3   data  >1000                 ; Binary 0001000000000000
0397 6032 0800     wbit4   data  >0800                 ; Binary 0000100000000000
0398 6034 0400     wbit5   data  >0400                 ; Binary 0000010000000000
0399 6036 0200     wbit6   data  >0200                 ; Binary 0000001000000000
0400 6038 0100     wbit7   data  >0100                 ; Binary 0000000100000000
0401 603A 0080     wbit8   data  >0080                 ; Binary 0000000010000000
0402 603C 0040     wbit9   data  >0040                 ; Binary 0000000001000000
0403 603E 0020     wbit10  data  >0020                 ; Binary 0000000000100000
0404 6040 0010     wbit11  data  >0010                 ; Binary 0000000000010000
0405 6042 0008     wbit12  data  >0008                 ; Binary 0000000000001000
0406 6044 0004     wbit13  data  >0004                 ; Binary 0000000000000100
0407 6046 0002     wbit14  data  >0002                 ; Binary 0000000000000010
0408 6048 0001     wbit15  data  >0001                 ; Binary 0000000000000001
0409 604A FFFF     whffff  data  >ffff                 ; Binary 1111111111111111
0410 604C 0001     bd0     byte  0                     ; Digit 0
0411               bd1     byte  1                     ; Digit 1
0412 604E 0203     bd2     byte  2                     ; Digit 2
0413               bd3     byte  3                     ; Digit 3
0414 6050 0405     bd4     byte  4                     ; Digit 4
0415               bd5     byte  5                     ; Digit 5
0416 6052 0607     bd6     byte  6                     ; Digit 6
0417               bd7     byte  7                     ; Digit 7
0418 6054 0809     bd8     byte  8                     ; Digit 8
0419               bd9     byte  9                     ; Digit 9
0420 6056 D000     bd208   byte  208                   ; Digit 208 (>D0)
0421                       even
0423               *--------------------------------------------------------------
0424               * Equates for constants
0425               *--------------------------------------------------------------
0426      6040     anykey  equ   wbit11                ; BIT 11 in the CONFIG register
0427      602A     bbit0   equ   wbit0
0428      602C     bbit1   equ   wbit1
0429      602E     bbit2   equ   wbit2
0430      6030     bbit3   equ   wbit3
0431      6032     bbit4   equ   wbit4
0432      6034     bbit5   equ   wbit5
0433      6036     bbit6   equ   wbit6
0434      6038     bbit7   equ   wbit7
0435      6041     bh10    equ   wbit11+1              ; >10
0436      603F     bh20    equ   wbit10+1              ; >20
0437      603D     bh40    equ   wbit9+1               ; >40
0438      603B     bh80    equ   wbit8+1               ; >80
0439      6048     wd1     equ   wbit15                ; >0001
0440      603E     wh20    equ   wbit10                ; >0020
0441      603C     wh40    equ   wbit9                 ; >0040
0442      603A     wh80    equ   wbit8                 ; >0080
0443      6038     wh100   equ   wbit7                 ; >0100
0444      602C     wh4000  equ   wbit1                 ; >4000
0445               
0446               
0447               ***************************************************************
0448               *                Data used by runtime library
0449               ********@*****@*********************@**************************
0450                       copy  "vdp_tables.asm"
**** **** ****     > vdp_tables.asm
0001               * FILE......: vdp_tables.a99
0002               * Purpose...: Video mode tables
0003               
0004               ***************************************************************
0005               * Graphics mode 1 (32 columns/24 rows)
0006               *--------------------------------------------------------------
0007 6058 00E2     graph1  byte  >00,>e2,>00,>0e,>01,>06,>02,SPFBCK,0,32
     605A 000E 
     605C 0106 
     605E 020C 
     6060 0020 
0008               * ; VDP#0 Control bits
0009               * ;      bit 6=0: M3 | Graphics 1 mode
0010               * ;      bit 7=0: Disable external VDP input
0011               * ; VDP#1 Control bits
0012               * ;      bit 0=1: 16K selection
0013               * ;      bit 1=1: Enable display
0014               * ;      bit 2=1: Enable VDP interrupt
0015               * ;      bit 3=0: M1 \ Graphics 1 mode
0016               * ;      bit 4=0: M2 /
0017               * ;      bit 5=0: reserved
0018               * ;      bit 6=1: 16x16 sprites
0019               * ;      bit 7=0: Sprite magnification (1x)
0020               * ; VDP#2 PNT (Pattern name table)       at >0000  (>00 * >400)
0021               * ; VDP#3 PCT (Pattern color table)      at >0380  (>0E * >040)
0022               * ; VDP#4 PDT (Pattern descriptor table) at >0800  (>01 * >800)
0023               * ; VDP#5 SAT (sprite attribute list)    at >0300  (>06 * >080)
0024               * ; VDP#6 SPT (Sprite pattern table)     at >1000  (>02 * >800)
0025               * ; VDP#7 Set screen background color
0026               ***************************************************************
0027               * Textmode (40 columns/24 rows)
0028               *--------------------------------------------------------------
0029 6062 00F2     tx4024  byte  >00,>f2,>00,>0e,>01,>06,>00,SPFCLR,0,40
     6064 000E 
     6066 0106 
     6068 001C 
     606A 0028 
0030               * ; VDP#0 Control bits
0031               * ;      bit 6=0: M3 | Graphics 1 mode
0032               * ;      bit 7=0: Disable external VDP input
0033               * ; VDP#1 Control bits
0034               * ;      bit 0=1: 16K selection
0035               * ;      bit 1=1: Enable display
0036               * ;      bit 2=1: Enable VDP interrupt
0037               * ;      bit 3=1: M1 \ TEXT MODE
0038               * ;      bit 4=0: M2 /
0039               * ;      bit 5=0: reserved
0040               * ;      bit 6=1: 16x16 sprites
0041               * ;      bit 7=0: Sprite magnification (1x)
0042               * ; VDP#2 PNT (Pattern name table)       at >0000  (>00 * >400)
0043               * ; VDP#3 PCT (Pattern color table)      at >0380  (>0E * >040)
0044               * ; VDP#4 PDT (Pattern descriptor table) at >0800  (>01 * >800)
0045               * ; VDP#5 SAT (sprite attribute list)    at >0300  (>06 * >080)
0046               * ; VDP#6 SPT (Sprite pattern table)     at >0000  (>00 * >800)
0047               * ; VDP#7 Set foreground/background color
0048               ***************************************************************
0049               
**** **** ****     > runlib.asm
0451               
0452 606C 678C     kdata   data  kernel                ; Address of kernel thread
0453               *--------------------------------------------------------------
0454               * ; Machine code for tight loop.
0455               * ; The MOV operation at MCLOOP must be injected by the calling routine.
0456               *--------------------------------------------------------------
0457               *       DATA  >????                 ; \ MCLOOP  MOV   ...
0458 606E 0606     mccode  data  >0606                 ; |         DEC   R6 (TMP2)
0459 6070 16FD             data  >16fd                 ; |         JNE   MCLOOP
0460 6072 045B             data  >045b                 ; /         B     *R11
0461               *--------------------------------------------------------------
0462               * ; Machine code for reading from the speech synthesizer
0463               * ; The SRC instruction takes 12 uS for execution in scratchpad RAM.
0464               * ; Is required for the 12 uS delay. It destroys R5.
0465               *--------------------------------------------------------------
0466 6074 D114     spcode  data  >d114                 ; \         MOVB  *R4,R4 (TMP0)
0467 6076 0BC5             data  >0bc5                 ; /         SRC   R5,12  (TMP1)
0468                       even
0469               
0470               
0471               *//////////////////////////////////////////////////////////////
0472               *                     FILL & COPY FUNCTIONS
0473               *//////////////////////////////////////////////////////////////
0474               
0475               
0476               
0477               ***************************************************************
0478               * FILM - Fill CPU memory with byte
0479               ***************************************************************
0480               *  BL   @FILM
0481               *  DATA P0,P1,P2
0482               *--------------------------------------------------------------
0483               *  P0 = Memory start address
0484               *  P1 = Byte to fill
0485               *  P2 = Number of bytes to fill
0486               *--------------------------------------------------------------
0487               *  BL   @XFILM
0488               *
0489               *  TMP0 = Memory start address
0490               *  TMP1 = Byte to fill
0491               *  TMP2 = Number of bytes to fill
0492               ********@*****@*********************@**************************
0493 6078 C13B  30 film    mov   *r11+,tmp0            ; Memory start
0494 607A C17B  30         mov   *r11+,tmp1            ; Byte to fill
0495 607C C1BB  30         mov   *r11+,tmp2            ; Repeat count
0496               *--------------------------------------------------------------
0497               * Fill memory with 16 bit words
0498               *--------------------------------------------------------------
0499 607E C1C6  18 xfilm   mov   tmp2,tmp3
0500 6080 0247  22         andi  tmp3,1                ; TMP3=1 -> ODD else EVEN
     6082 0001 
0501               
0502 6084 1301  14         jeq   film1
0503 6086 0606  14         dec   tmp2                  ; Make TMP2 even
0504 6088 D820  54 film1   movb  @tmp1lb,@tmp1hb       ; Duplicate value
     608A 830B 
     608C 830A 
0505 608E CD05  34 film2   mov   tmp1,*tmp0+
0506 6090 0646  14         dect  tmp2
0507 6092 16FD  14         jne   film2
0508               *--------------------------------------------------------------
0509               * Fill last byte if ODD
0510               *--------------------------------------------------------------
0511 6094 C1C7  18         mov   tmp3,tmp3
0512 6096 1301  14         jeq   filmz
0513 6098 D505  30         movb  tmp1,*tmp0
0514 609A 045B  20 filmz   b     *r11
0515               
0516               
0517               ***************************************************************
0518               * FILV - Fill VRAM with byte
0519               ***************************************************************
0520               *  BL   @FILV
0521               *  DATA P0,P1,P2
0522               *--------------------------------------------------------------
0523               *  P0 = VDP start address
0524               *  P1 = Byte to fill
0525               *  P2 = Number of bytes to fill
0526               *--------------------------------------------------------------
0527               *  BL   @XFILV
0528               *
0529               *  TMP0 = VDP start address
0530               *  TMP1 = Byte to fill
0531               *  TMP2 = Number of bytes to fill
0532               ********@*****@*********************@**************************
0533 609C C13B  30 filv    mov   *r11+,tmp0            ; Memory start
0534 609E C17B  30         mov   *r11+,tmp1            ; Byte to fill
0535 60A0 C1BB  30         mov   *r11+,tmp2            ; Repeat count
0536               *--------------------------------------------------------------
0537               *    Setup VDP write address
0538               *--------------------------------------------------------------
0539 60A2 0264  22 xfilv   ori   tmp0,>4000
     60A4 4000 
0540 60A6 06C4  14         swpb  tmp0
0541 60A8 D804  38         movb  tmp0,@vdpa
     60AA 8C02 
0542 60AC 06C4  14         swpb  tmp0
0543 60AE D804  38         movb  tmp0,@vdpa
     60B0 8C02 
0544               *--------------------------------------------------------------
0545               *    Fill bytes in VDP memory
0546               *--------------------------------------------------------------
0547 60B2 020F  20         li    r15,vdpw              ; Set VDP write address
     60B4 8C00 
0548 60B6 06C5  14         swpb  tmp1
0549 60B8 C820  54         mov   @filzz,@mcloop        ; Setup move command
     60BA 60C2 
     60BC 8320 
0550 60BE 0460  28         b     @mcloop               ; Write data to VDP
     60C0 8320 
0551 60C2 D7C5     filzz   data  >d7c5                 ; MOVB TMP1,*R15
0552               
0553               
0554               ***************************************************************
0555               * CPYM2M - Copy CPU memory to CPU memory
0556               ***************************************************************
0557               *  BL   @CPYM2M
0558               *  DATA P0,P1,P2
0559               *--------------------------------------------------------------
0560               *  P0 = Memory source address
0561               *  P1 = Memory target address
0562               *  P2 = Number of bytes to copy
0563               *--------------------------------------------------------------
0564               *  BL @XPYM2M
0565               *
0566               *  TMP0 = Memory source address
0567               *  TMP1 = Memory target address
0568               *  TMP2 = Number of bytes to copy
0569               ********@*****@*********************@**************************
0570 60C4 C13B  30 cpym2m  mov   *r11+,tmp0            ; Memory source address
0571 60C6 C17B  30         mov   *r11+,tmp1            ; Memory target address
0572 60C8 C1BB  30         mov   *r11+,tmp2            ; Number of bytes to copy
0573               *--------------------------------------------------------------
0574               * Do some checks first
0575               *--------------------------------------------------------------
0576 60CA 024C  22 xpym2m  andi  config,>7fff          ; Clear CONFIG bit 0
     60CC 7FFF 
0577 60CE C1C4  18         mov   tmp0,tmp3
0578 60D0 0247  22         andi  tmp3,1
     60D2 0001 
0579 60D4 1618  14         jne   cpyodd                ; Odd source address handling
0580 60D6 C1C5  18 cpym1   mov   tmp1,tmp3
0581 60D8 0247  22         andi  tmp3,1
     60DA 0001 
0582 60DC 1614  14         jne   cpyodd                ; Odd target address handling
0583               *--------------------------------------------------------------
0584               * 8 bit copy
0585               *--------------------------------------------------------------
0586 60DE 2320  38 cpym2   coc   @wbit0,config         ; CONFIG bit 0 set ?
     60E0 602A 
0587 60E2 1605  14         jne   cpym3
0588 60E4 C820  54         mov   @tmp011,@mcloop       ; Setup byte copy command
     60E6 610C 
     60E8 8320 
0589 60EA 0460  28         b     @mcloop               ; Copy memory and exit
     60EC 8320 
0590               *--------------------------------------------------------------
0591               * 16 bit copy
0592               *--------------------------------------------------------------
0593 60EE C1C6  18 cpym3   mov   tmp2,tmp3
0594 60F0 0247  22         andi  tmp3,1                ; TMP3=1 -> ODD else EVEN
     60F2 0001 
0595 60F4 1301  14         jeq   cpym4
0596 60F6 0606  14         dec   tmp2                  ; Make TMP2 even
0597 60F8 CD74  46 cpym4   mov   *tmp0+,*tmp1+
0598 60FA 0646  14         dect  tmp2
0599 60FC 16FD  14         jne   cpym4
0600               *--------------------------------------------------------------
0601               * Copy last byte if ODD
0602               *--------------------------------------------------------------
0603 60FE C1C7  18         mov   tmp3,tmp3
0604 6100 1301  14         jeq   cpymz
0605 6102 D554  38         movb  *tmp0,*tmp1
0606 6104 045B  20 cpymz   b     *r11
0607               *--------------------------------------------------------------
0608               * Handle odd source/target address
0609               *--------------------------------------------------------------
0610 6106 026C  22 cpyodd  ori   config,>8000        ; Set CONFIG bot 0
     6108 8000 
0611 610A 10E9  14         jmp   cpym2
0612 610C DD74     tmp011  data  >dd74               ; MOVB *TMP0+,*TMP1+
0613               
0614               
0615               ***************************************************************
0616               * CPYM2V - Copy CPU memory to VRAM
0617               ***************************************************************
0618               *  BL   @CPYM2V
0619               *  DATA P0,P1,P2
0620               *--------------------------------------------------------------
0621               *  P0 = VDP start address
0622               *  P1 = RAM/ROM start address
0623               *  P2 = Number of bytes to copy
0624               *--------------------------------------------------------------
0625               *  BL @XPYM2V
0626               *
0627               *  TMP0 = VDP start address
0628               *  TMP1 = RAM/ROM start address
0629               *  TMP2 = Number of bytes to copy
0630               ********@*****@*********************@**************************
0631 610E C13B  30 cpym2v  mov   *r11+,tmp0            ; VDP Start address
0632 6110 C17B  30         mov   *r11+,tmp1            ; RAM/ROM start address
0633 6112 C1BB  30         mov   *r11+,tmp2            ; Bytes to copy
0634               *--------------------------------------------------------------
0635               *    Setup VDP write address
0636               *--------------------------------------------------------------
0637 6114 0264  22 xpym2v  ori   tmp0,>4000
     6116 4000 
0638 6118 06C4  14         swpb  tmp0
0639 611A D804  38         movb  tmp0,@vdpa
     611C 8C02 
0640 611E 06C4  14         swpb  tmp0
0641 6120 D804  38         movb  tmp0,@vdpa
     6122 8C02 
0642               *--------------------------------------------------------------
0643               *    Copy bytes from CPU memory to VRAM
0644               *--------------------------------------------------------------
0645 6124 020F  20         li    r15,vdpw              ; Set VDP write address
     6126 8C00 
0646 6128 C820  54         mov   @tmp008,@mcloop       ; Setup copy command
     612A 6132 
     612C 8320 
0647 612E 0460  28         b     @mcloop               ; Write data to VDP
     6130 8320 
0648 6132 D7F5     tmp008  data  >d7f5                 ; MOVB *TMP1+,*R15
0649               
0650               
0651               ***************************************************************
0652               * CPYV2M - Copy VRAM to CPU memory
0653               ***************************************************************
0654               *  BL   @CPYV2M
0655               *  DATA P0,P1,P2
0656               *--------------------------------------------------------------
0657               *  P0 = VDP source address
0658               *  P1 = RAM target address
0659               *  P2 = Number of bytes to copy
0660               *--------------------------------------------------------------
0661               *  BL @XPYV2M
0662               *
0663               *  TMP0 = VDP source address
0664               *  TMP1 = RAM target address
0665               *  TMP2 = Number of bytes to copy
0666               ********@*****@*********************@**************************
0667 6134 C13B  30 cpyv2m  mov   *r11+,tmp0            ; VDP source address
0668 6136 C17B  30         mov   *r11+,tmp1            ; Target address in RAM
0669 6138 C1BB  30         mov   *r11+,tmp2            ; Bytes to copy
0670               *--------------------------------------------------------------
0671               *    Setup VDP read address
0672               *--------------------------------------------------------------
0673 613A 06C4  14 xpyv2m  swpb  tmp0
0674 613C D804  38         movb  tmp0,@vdpa
     613E 8C02 
0675 6140 06C4  14         swpb  tmp0
0676 6142 D804  38         movb  tmp0,@vdpa
     6144 8C02 
0677               *--------------------------------------------------------------
0678               *    Copy bytes from VDP memory to RAM
0679               *--------------------------------------------------------------
0680 6146 020F  20         li    r15,vdpr              ; Set VDP read address
     6148 8800 
0681 614A C820  54         mov   @tmp007,@mcloop       ; Setup copy command
     614C 6154 
     614E 8320 
0682 6150 0460  28         b     @mcloop               ; Read data from VDP
     6152 8320 
0683 6154 DD5F     tmp007  data  >dd5f                 ; MOVB *R15,*TMP+
0684               
0685               
0686               
0687               *//////////////////////////////////////////////////////////////
0688               *                    GROM copy functions
0689               *//////////////////////////////////////////////////////////////
0691                       copy  "grom_support.asm"
**** **** ****     > grom_support.asm
0001               * FILE......: grom_support.asm
0002               * Purpose...: GROM copy/support module
0003               
0004               *//////////////////////////////////////////////////////////////
0005               *                       GROM COPY FUNCTIONS
0006               *//////////////////////////////////////////////////////////////
0007               
0008               
0009               ***************************************************************
0010               * CPYG2M - Copy GROM memory to CPU memory
0011               ***************************************************************
0012               *  BL   @CPYG2M
0013               *  DATA P0,P1,P2
0014               *--------------------------------------------------------------
0015               *  P0 = GROM source address
0016               *  P1 = CPU target address
0017               *  P2 = Number of bytes to copy
0018               *--------------------------------------------------------------
0019               *  BL @CPYG2M
0020               *
0021               *  TMP0 = GROM source address
0022               *  TMP1 = CPU target address
0023               *  TMP2 = Number of bytes to copy
0024               ********@*****@*********************@**************************
0025 6156 C13B  30 cpyg2m  mov   *r11+,tmp0            ; Memory source address
0026 6158 C17B  30         mov   *r11+,tmp1            ; Memory target address
0027 615A C1BB  30         mov   *r11+,tmp2            ; Number of bytes to copy
0028               *--------------------------------------------------------------
0029               * Setup GROM source address
0030               *--------------------------------------------------------------
0031 615C D804  38 xpyg2m  movb  tmp0,@grmwa
     615E 9C02 
0032 6160 06C4  14         swpb  tmp0
0033 6162 D804  38         movb  tmp0,@grmwa
     6164 9C02 
0034               *--------------------------------------------------------------
0035               *    Copy bytes from GROM to CPU memory
0036               *--------------------------------------------------------------
0037 6166 0204  20         li    tmp0,grmrd            ; Set TMP0 to GROM data port
     6168 9800 
0038 616A C820  54         mov   @tmp003,@mcloop       ; Setup copy command
     616C 6174 
     616E 8320 
0039 6170 0460  28         b     @mcloop               ; Copy bytes
     6172 8320 
0040 6174 DD54     tmp003  data  >dd54                 ; MOVB *TMP0,*TMP1+
0041               
0042               
0043               ***************************************************************
0044               * CPYG2V - Copy GROM memory to VRAM memory
0045               ***************************************************************
0046               *  BL   @CPYG2V
0047               *  DATA P0,P1,P2
0048               *--------------------------------------------------------------
0049               *  P0 = GROM source address
0050               *  P1 = VDP target address
0051               *  P2 = Number of bytes to copy
0052               *--------------------------------------------------------------
0053               *  BL @CPYG2V
0054               *
0055               *  TMP0 = GROM source address
0056               *  TMP1 = VDP target address
0057               *  TMP2 = Number of bytes to copy
0058               ********@*****@*********************@**************************
0059 6176 C13B  30 cpyg2v  mov   *r11+,tmp0            ; Memory source address
0060 6178 C17B  30         mov   *r11+,tmp1            ; Memory target address
0061 617A C1BB  30         mov   *r11+,tmp2            ; Number of bytes to copy
0062               *--------------------------------------------------------------
0063               * Setup GROM source address
0064               *--------------------------------------------------------------
0065 617C D804  38 xpyg2v  movb  tmp0,@grmwa
     617E 9C02 
0066 6180 06C4  14         swpb  tmp0
0067 6182 D804  38         movb  tmp0,@grmwa
     6184 9C02 
0068               *--------------------------------------------------------------
0069               * Setup VDP target address
0070               *--------------------------------------------------------------
0071 6186 0265  22         ori   tmp1,>4000
     6188 4000 
0072 618A 06C5  14         swpb  tmp1
0073 618C D805  38         movb  tmp1,@vdpa
     618E 8C02 
0074 6190 06C5  14         swpb  tmp1
0075 6192 D805  38         movb  tmp1,@vdpa            ; Set VDP target address
     6194 8C02 
0076               *--------------------------------------------------------------
0077               *    Copy bytes from GROM to VDP memory
0078               *--------------------------------------------------------------
0079 6196 0207  20         li    tmp3,grmrd            ; Set TMP3 to GROM data port
     6198 9800 
0080 619A 020F  20         li    r15,vdpw              ; Set VDP write address
     619C 8C00 
0081 619E C820  54         mov   @tmp002,@mcloop       ; Setup copy command
     61A0 61A8 
     61A2 8320 
0082 61A4 0460  28         b     @mcloop               ; Copy bytes
     61A6 8320 
0083 61A8 D7D7     tmp002  data  >d7d7                 ; MOVB *TMP3,*R15
**** **** ****     > runlib.asm
0693               
0694               
0695               ***************************************************************
0696               * RLE2V - RLE decompress to VRAM memory
0697               ***************************************************************
0698               *  BL   @RLE2V
0699               *  DATA P0,P1,P2
0700               *--------------------------------------------------------------
0701               *  P0 = ROM/RAM source address
0702               *  P1 = VDP target address
0703               *  P2 = Length of RLE encoded data
0704               *--------------------------------------------------------------
0705               *  BL @RLE2VX
0706               *
0707               *  TMP0     = VDP target address
0708               *  TMP2 (!) = ROM/RAM source address
0709               *  TMP3 (!) = Length of RLE encoded data
0710               *--------------------------------------------------------------
0711               *  Detail on RLE compression format:
0712               *  - If high bit is set, remaining 7 bits indicate to copy
0713               *    the next byte that many times.
0714               *  - If high bit is clear, remaining 7 bits indicate how many
0715               *    data bytes (non-repeated) follow.
0716               ********@*****@*********************@**************************
0717 61AA C1BB  30 rle2v   mov   *r11+,tmp2            ; ROM/RAM source address
0718 61AC C13B  30         mov   *r11+,tmp0            ; VDP target address
0719 61AE C1FB  30         mov   *r11+,tmp3            ; Length of RLE encoded data
0720 61B0 C80B  38         mov   r11,@waux1            ; Save return address
     61B2 833C 
0721 61B4 06A0  32 rle2vx  bl    @vdwa                 ; Setup VDP address from TMP0
     61B6 61F0 
0722 61B8 C106  18         mov   tmp2,tmp0             ; We can safely reuse TMP0 now
0723 61BA D1B4  28 rle2v0  movb  *tmp0+,tmp2           ; Get control byte into TMP2
0724 61BC 0607  14         dec   tmp3                  ; Update length
0725 61BE 1314  14         jeq   rle2vz                ; End of list
0726 61C0 0A16  56         sla   tmp2,1                ; Check bit 0 of control byte
0727 61C2 1808  14         joc   rle2v2                ; Yes, next byte is compressed
0728               *--------------------------------------------------------------
0729               *    Dump uncompressed bytes
0730               *--------------------------------------------------------------
0731 61C4 C820  54 rle2v1  mov   @rledat,@mcloop       ; Setup machine code (MOVB *TMP0+,*R15)
     61C6 61EE 
     61C8 8320 
0732 61CA 0996  56         srl   tmp2,9                ; Use control byte as counter
0733 61CC 61C6  18         s     tmp2,tmp3             ; Update length
0734 61CE 06A0  32         bl    @mcloop               ; Write data to VDP
     61D0 8320 
0735 61D2 1008  14         jmp   rle2v3
0736               *--------------------------------------------------------------
0737               *    Dump compressed bytes
0738               *--------------------------------------------------------------
0739 61D4 C820  54 rle2v2  mov   @filzz,@mcloop        ; Setup machine code(MOVB TMP1,*R15)
     61D6 60C2 
     61D8 8320 
0740 61DA 0996  56         srl   tmp2,9                ; Use control byte as counter
0741 61DC 0607  14         dec   tmp3                  ; Update length
0742 61DE D174  28         movb  *tmp0+,tmp1           ; Byte to fill
0743 61E0 06A0  32         bl    @mcloop               ; Write data to VDP
     61E2 8320 
0744               *--------------------------------------------------------------
0745               *    Check if more data to decompress
0746               *--------------------------------------------------------------
0747 61E4 C1C7  18 rle2v3  mov   tmp3,tmp3             ; Length counter = 0 ?
0748 61E6 16E9  14         jne   rle2v0                ; Not yet, process data
0749               *--------------------------------------------------------------
0750               *    Exit
0751               *--------------------------------------------------------------
0752 61E8 C2E0  34 rle2vz  mov   @waux1,r11
     61EA 833C 
0753 61EC 045B  20         b     *r11                  ; Return
0754 61EE D7F4     rledat  data  >d7f4                 ; MOVB *TMP0+,*R15
0755               
0756               
0757               
0758               
0759               *//////////////////////////////////////////////////////////////
0760               *                      VDP LOW LEVEL FUNCTIONS
0761               *//////////////////////////////////////////////////////////////
0762               
0763               ***************************************************************
0764               * VDWA / VDRA - Setup VDP write or read address
0765               ***************************************************************
0766               *  BL   @VDWA
0767               *
0768               *  TMP0 = VDP destination address for write
0769               *--------------------------------------------------------------
0770               *  BL   @VDRA
0771               *
0772               *  TMP0 = VDP source address for read
0773               ********@*****@*********************@**************************
0774 61F0 0264  22 vdwa    ori   tmp0,>4000            ; Prepare VDP address for write
     61F2 4000 
0775 61F4 06C4  14 vdra    swpb  tmp0
0776 61F6 D804  38         movb  tmp0,@vdpa
     61F8 8C02 
0777 61FA 06C4  14         swpb  tmp0
0778 61FC D804  38         movb  tmp0,@vdpa            ; Set VDP address
     61FE 8C02 
0779 6200 045B  20         b     *r11
0780               
0781               ***************************************************************
0782               * VPUTB - VDP put single byte
0783               ***************************************************************
0784               *  BL @VPUTB
0785               *  DATA P0,P1
0786               *--------------------------------------------------------------
0787               *  P0 = VDP target address
0788               *  P1 = Byte to write
0789               ********@*****@*********************@**************************
0790 6202 C13B  30 vputb   mov   *r11+,tmp0            ; Get VDP target address
0791 6204 C17B  30         mov   *r11+,tmp1
0792 6206 C18B  18 xvputb  mov   r11,tmp2              ; Save R11
0793 6208 06A0  32         bl    @vdwa                 ; Set VDP write address
     620A 61F0 
0794               
0795 620C 06C5  14         swpb  tmp1                  ; Get byte to write
0796 620E D7C5  30         movb  tmp1,*r15             ; Write byte
0797 6210 0456  20         b     *tmp2                 ; Exit
0798               
0799               
0800               ***************************************************************
0801               * VGETB - VDP get single byte
0802               ***************************************************************
0803               *  BL @VGETB
0804               *  DATA P0
0805               *--------------------------------------------------------------
0806               *  P0 = VDP source address
0807               ********@*****@*********************@**************************
0808 6212 C13B  30 vgetb   mov   *r11+,tmp0            ; Get VDP source address
0809 6214 C18B  18 xvgetb  mov   r11,tmp2              ; Save R11
0810 6216 06A0  32         bl    @vdra                 ; Set VDP read address
     6218 61F4 
0811               
0812 621A D120  34         movb  @vdpr,tmp0            ; Read byte
     621C 8800 
0813               
0814 621E 0984  56         srl   tmp0,8                ; Right align
0815 6220 0456  20         b     *tmp2                 ; Exit
0816               
0817               ***************************************************************
0818               * VIDTAB - Dump videomode table
0819               ***************************************************************
0820               *  BL   @VIDTAB
0821               *  DATA P0
0822               *--------------------------------------------------------------
0823               *  P0 = Address of video mode table
0824               *--------------------------------------------------------------
0825               *  BL   @XIDTAB
0826               *
0827               *  TMP0 = Address of video mode table
0828               *--------------------------------------------------------------
0829               *  Remarks
0830               *  TMP1 = MSB is the VDP target register
0831               *         LSB is the value to write
0832               ********@*****@*********************@**************************
0833 6222 C13B  30 vidtab  mov   *r11+,tmp0            ; Get video mode table
0834 6224 C394  26 xidtab  mov   *tmp0,r14             ; Store copy of VDP#0 and #1 in RAM
0835               *--------------------------------------------------------------
0836               * Calculate PNT base address
0837               *--------------------------------------------------------------
0838 6226 C144  18         mov   tmp0,tmp1
0839 6228 05C5  14         inct  tmp1
0840 622A D155  26         movb  *tmp1,tmp1            ; Get value for VDP#2
0841 622C 0245  22         andi  tmp1,>ff00            ; Only keep MSB
     622E FF00 
0842 6230 0A25  56         sla   tmp1,2                ; TMP1 *= 400
0843 6232 C805  38         mov   tmp1,@wbase           ; Store calculated base
     6234 8328 
0844               *--------------------------------------------------------------
0845               * Dump VDP shadow registers
0846               *--------------------------------------------------------------
0847 6236 0205  20         li    tmp1,>8000            ; Start with VDP register 0
     6238 8000 
0848 623A 0206  20         li    tmp2,8
     623C 0008 
0849 623E D834  48 vidta1  movb  *tmp0+,@tmp1lb        ; Write value to VDP register
     6240 830B 
0850 6242 06C5  14         swpb  tmp1
0851 6244 D805  38         movb  tmp1,@vdpa
     6246 8C02 
0852 6248 06C5  14         swpb  tmp1
0853 624A D805  38         movb  tmp1,@vdpa
     624C 8C02 
0854 624E 0225  22         ai    tmp1,>0100
     6250 0100 
0855 6252 0606  14         dec   tmp2
0856 6254 16F4  14         jne   vidta1                ; Next register
0857 6256 C814  46         mov   *tmp0,@wcolmn         ; Store # of columns per row
     6258 833A 
0858 625A 045B  20         b     *r11
0859               
0860               
0861               ***************************************************************
0862               * PUTVR  - Put single VDP register
0863               ***************************************************************
0864               *  BL   @PUTVR
0865               *  DATA P0
0866               *--------------------------------------------------------------
0867               *  P0 = MSB is the VDP target register
0868               *       LSB is the value to write
0869               *--------------------------------------------------------------
0870               *  BL   @PUTVRX
0871               *
0872               *  TMP0 = MSB is the VDP target register
0873               *         LSB is the value to write
0874               ********@*****@*********************@**************************
0875 625C C13B  30 putvr   mov   *r11+,tmp0
0876 625E 0264  22 putvrx  ori   tmp0,>8000
     6260 8000 
0877 6262 06C4  14         swpb  tmp0
0878 6264 D804  38         movb  tmp0,@vdpa
     6266 8C02 
0879 6268 06C4  14         swpb  tmp0
0880 626A D804  38         movb  tmp0,@vdpa
     626C 8C02 
0881 626E 045B  20         b     *r11
0882               
0883               ***************************************************************
0884               * PUTV01  - Put VDP registers #0 and #1
0885               ***************************************************************
0886               *  BL   @PUTV01
0887               ********@*****@*********************@**************************
0888 6270 C20B  18 putv01  mov   r11,tmp4              ; Save R11
0889 6272 C10E  18         mov   r14,tmp0
0890 6274 0984  56         srl   tmp0,8
0891 6276 06A0  32         bl    @putvrx               ; Write VR#0
     6278 625E 
0892 627A 0204  20         li    tmp0,>0100
     627C 0100 
0893 627E D820  54         movb  @r14lb,@tmp0lb
     6280 831D 
     6282 8309 
0894 6284 06A0  32         bl    @putvrx               ; Write VR#1
     6286 625E 
0895 6288 0458  20         b     *tmp4                 ; Exit
0896               
0897               ***************************************************************
0898               * SCROFF - Disable screen display
0899               ***************************************************************
0900               *  BL @SCROFF
0901               ********@*****@*********************@**************************
0902 628A 024E  22 scroff  andi  r14,>ffbf             ; VDP#R1 bit 1=0 (Disable screen display)
     628C FFBF 
0903 628E 10F0  14         jmp   putv01
0904               
0905               ***************************************************************
0906               * SCRON - Disable screen display
0907               ***************************************************************
0908               *  BL @SCRON
0909               ********@*****@*********************@**************************
0910 6290 026E  22 scron   ori   r14,>0040             ; VDP#R1 bit 1=1 (Enable screen display)
     6292 0040 
0911 6294 10ED  14         jmp   putv01
0912               
0913               ***************************************************************
0914               * INTOFF - Disable VDP interrupt
0915               ***************************************************************
0916               *  BL @INTOFF
0917               ********@*****@*********************@**************************
0918 6296 024E  22 intoff  andi  r14,>ffdf             ; VDP#R1 bit 2=0 (Disable VDP interrupt)
     6298 FFDF 
0919 629A 10EA  14         jmp   putv01
0920               
0921               ***************************************************************
0922               * INTON - Enable VDP interrupt
0923               ***************************************************************
0924               *  BL @INTON
0925               ********@*****@*********************@**************************
0926 629C 026E  22 inton   ori   r14,>0020             ; VDP#R1 bit 2=1 (Enable VDP interrupt)
     629E 0020 
0927 62A0 10E7  14         jmp   putv01
0928               
0929               ***************************************************************
0930               * SMAG1X - Set sprite magnification 1x
0931               ***************************************************************
0932               *  BL @SMAG1X
0933               ********@*****@*********************@**************************
0934 62A2 024E  22 smag1x  andi  r14,>fffe             ; VDP#R1 bit 7=0 (Sprite magnification 1x)
     62A4 FFFE 
0935 62A6 10E4  14         jmp   putv01
0936               
0937               ***************************************************************
0938               * SMAG2X - Set sprite magnification 2x
0939               ***************************************************************
0940               *  BL @SMAG2X
0941               ********@*****@*********************@**************************
0942 62A8 026E  22 smag2x  ori   r14,>0001             ; VDP#R1 bit 7=1 (Sprite magnification 2x)
     62AA 0001 
0943 62AC 10E1  14         jmp   putv01
0944               
0945               ***************************************************************
0946               * S8X8 - Set sprite size 8x8 bits
0947               ***************************************************************
0948               *  BL @S8X8
0949               ********@*****@*********************@**************************
0950 62AE 024E  22 s8x8    andi  r14,>fffd             ; VDP#R1 bit 6=0 (Sprite size 8x8)
     62B0 FFFD 
0951 62B2 10DE  14         jmp   putv01
0952               
0953               ***************************************************************
0954               * S16X16 - Set sprite size 16x16 bits
0955               ***************************************************************
0956               *  BL @S16X16
0957               ********@*****@*********************@**************************
0958 62B4 026E  22 s16x16  ori   r14,>0002             ; VDP#R1 bit 6=1 (Sprite size 16x16)
     62B6 0002 
0959 62B8 10DB  14         jmp   putv01
0960               
0961               ***************************************************************
0962               * YX2PNT - Get VDP PNT address for current YX cursor position
0963               ***************************************************************
0964               *  BL   @YX2PNT
0965               *--------------------------------------------------------------
0966               *  INPUT
0967               *  @WYX = Cursor YX position
0968               *--------------------------------------------------------------
0969               *  OUTPUT
0970               *  TMP0 = VDP address for entry in Pattern Name Table
0971               *--------------------------------------------------------------
0972               *  Register usage
0973               *  TMP0, R14, R15
0974               ********@*****@*********************@**************************
0975 62BA C10E  18 yx2pnt  mov   r14,tmp0              ; Save VDP#0 & VDP#1
0976 62BC C3A0  34         mov   @wyx,r14              ; Get YX
     62BE 832A 
0977 62C0 098E  56         srl   r14,8                 ; Right justify (remove X)
0978 62C2 3BA0  72         mpy   @wcolmn,r14           ; pos = Y * (columns per row)
     62C4 833A 
0979               *--------------------------------------------------------------
0980               * Do rest of calculation with R15 (16 bit part is there)
0981               * Re-use R14
0982               *--------------------------------------------------------------
0983 62C6 C3A0  34         mov   @wyx,r14              ; Get YX
     62C8 832A 
0984 62CA 024E  22         andi  r14,>00ff             ; Remove Y
     62CC 00FF 
0985 62CE A3CE  18         a     r14,r15               ; pos = pos + X
0986 62D0 A3E0  34         a     @wbase,r15            ; pos = pos + (PNT base address)
     62D2 8328 
0987               *--------------------------------------------------------------
0988               * Clean up before exit
0989               *--------------------------------------------------------------
0990 62D4 C384  18         mov   tmp0,r14              ; Restore VDP#0 & VDP#1
0991 62D6 C10F  18         mov   r15,tmp0              ; Return pos in TMP0
0992 62D8 020F  20         li    r15,vdpw              ; VDP write address
     62DA 8C00 
0993 62DC 045B  20         b     *r11
0994               
0995               ***************************************************************
0996               * YX2PX - Get pixel position for cursor YX position
0997               ***************************************************************
0998               *  BL   @YX2PX
0999               *
1000               *  (CONFIG:0 = 1) = Skip sprite adjustment
1001               *--------------------------------------------------------------
1002               *  INPUT
1003               *  @WYX   = Cursor YX position
1004               *--------------------------------------------------------------
1005               *  OUTPUT
1006               *  TMP0HB = Y pixel position
1007               *  TMP0LB = X pixel position
1008               *--------------------------------------------------------------
1009               *  Remarks
1010               *  This subroutine does not support multicolor or text mode
1011               ********@*****@*********************@**************************
1012 62DE C120  34 yx2px   mov   @wyx,tmp0
     62E0 832A 
1013 62E2 C18B  18 yx2pxx  mov   r11,tmp2              ; Save return address
1014 62E4 06C4  14         swpb  tmp0                  ; Y<->X
1015 62E6 04C5  14         clr   tmp1                  ; Clear before copy
1016 62E8 D144  18         movb  tmp0,tmp1             ; Copy X to TMP1
1017 62EA 0A35  56         sla   tmp1,3                ; X=X*8
1018 62EC 0A34  56         sla   tmp0,3                ; Y=Y*8
1019 62EE D105  18         movb  tmp1,tmp0
1020 62F0 06C4  14         swpb  tmp0                  ; X<->Y
1021 62F2 2320  38 yx2pi1  coc   @wbit0,config         ; Skip sprite adjustment ?
     62F4 602A 
1022 62F6 1305  14         jeq   yx2pi3                ; Yes, exit
1023               *--------------------------------------------------------------
1024               * Adjust for Y sprite location
1025               * See VDP Programmers Guide, Section 9.2.1
1026               *--------------------------------------------------------------
1027 62F8 7120  34 yx2pi2  sb    @bd1,tmp0             ; Adjust Y. Top of screen is at >FF
     62FA 604D 
1028 62FC 9120  34         cb    @bd208,tmp0           ; Y position = >D0 ?
     62FE 6056 
1029 6300 13FB  14         jeq   yx2pi2                ; Yes, but that's not allowed, correct
1030 6302 0456  20 yx2pi3  b     *tmp2                 ; Exit
1031 6304 2000     bdig32  data  >2000
1032               
1033               
1034               ***************************************************************
1035               * PX2YX - Get YX tile position for specified YX pixel position
1036               ***************************************************************
1037               *  BL   @PX2YX
1038               *--------------------------------------------------------------
1039               *  INPUT
1040               *  TMP0   = Pixel YX position
1041               *
1042               *  (CONFIG:0 = 1) = Skip sprite adjustment
1043               *--------------------------------------------------------------
1044               *  OUTPUT
1045               *  TMP0HB = Y tile position
1046               *  TMP0LB = X tile position
1047               *  TMP1HB = Y pixel offset
1048               *  TMP1LB = X pixel offset
1049               *--------------------------------------------------------------
1050               *  Remarks
1051               *  This subroutine does not support multicolor or text mode
1052               ********@*****@*********************@**************************
1053 6306 2320  38 px2yx   coc   @wbit0,config         ; Skip sprite adjustment ?
     6308 602A 
1054 630A 1302  14         jeq   px2yx1
1055 630C 0224  22         ai    tmp0,>0100            ; Adjust Y. Top of screen is at >FF
     630E 0100 
1056 6310 C144  18 px2yx1  mov   tmp0,tmp1             ; Copy YX
1057 6312 C184  18         mov   tmp0,tmp2             ; Copy YX
1058               *--------------------------------------------------------------
1059               * Calculate Y tile position
1060               *--------------------------------------------------------------
1061 6314 09B4  56         srl   tmp0,11               ; Y: Move to TMP0LB & (Y = Y / 8)
1062               *--------------------------------------------------------------
1063               * Calculate Y pixel offset
1064               *--------------------------------------------------------------
1065 6316 C1C4  18         mov   tmp0,tmp3             ; Y: Copy Y tile to TMP3LB
1066 6318 0AB7  56         sla   tmp3,11               ; Y: Move to TMP3HB & (Y = Y * 8)
1067 631A 0507  16         neg   tmp3
1068 631C B1C5  18         ab    tmp1,tmp3             ; Y: offset = Y pixel old + (-Y) pixel new
1069               *--------------------------------------------------------------
1070               * Calculate X tile position
1071               *--------------------------------------------------------------
1072 631E 0245  22         andi  tmp1,>00ff            ; Clear TMP1HB
     6320 00FF 
1073 6322 0A55  56         sla   tmp1,5                ; X: Move to TMP1HB & (X = X / 8)
1074 6324 D105  18         movb  tmp1,tmp0             ; X: TMP0 <-- XY tile position
1075 6326 06C4  14         swpb  tmp0                  ; XY tile position <-> YX tile position
1076               *--------------------------------------------------------------
1077               * Calculate X pixel offset
1078               *--------------------------------------------------------------
1079 6328 0245  22         andi  tmp1,>ff00            ; X: Get rid of remaining junk in TMP1LB
     632A FF00 
1080 632C 0A35  56         sla   tmp1,3                ; X: (X = X * 8)
1081 632E 0505  16         neg   tmp1
1082 6330 06C6  14         swpb  tmp2                  ; YX <-> XY
1083 6332 B146  18         ab    tmp2,tmp1             ; offset X = X pixel old  + (-X) pixel new
1084 6334 06C5  14         swpb  tmp1                  ; X0 <-> 0X
1085 6336 D147  18         movb  tmp3,tmp1             ; 0X --> YX
1086 6338 045B  20         b     *r11                  ; Exit
1087               
1088               *//////////////////////////////////////////////////////////////
1089               *                    VDP BITMAP FUNCTIONS
1090               *//////////////////////////////////////////////////////////////
1095               
1096               *//////////////////////////////////////////////////////////////
1097               *                 VDP F18A LOW-LEVEL FUNCTIONS
1098               *//////////////////////////////////////////////////////////////
1103               
1104               *//////////////////////////////////////////////////////////////
1105               *                      VDP TILE FUNCTIONS
1106               *//////////////////////////////////////////////////////////////
1107               
1108               ***************************************************************
1109               * LDFNT - Load TI-99/4A font from GROM into VDP
1110               ***************************************************************
1111               *  BL   @LDFNT
1112               *  DATA P0,P1
1113               *--------------------------------------------------------------
1114               *  P0 = VDP Target address
1115               *  P1 = Font options
1116               ********@*****@*********************@**************************
1117 633A C20B  18 ldfnt   mov   r11,tmp4              ; Save R11
1118 633C 05CB  14         inct  r11                   ; Get 2nd parameter (font options)
1119 633E C11B  26         mov   *r11,tmp0             ; Get parameter value
1120 6340 024C  22         andi  config,>7fff          ; CONFIG register bit 0=0
     6342 7FFF 
1121 6344 2120  38         coc   @wbit0,tmp0
     6346 602A 
1122 6348 1604  14         jne   ldfnt1
1123 634A 026C  22         ori   config,>8000          ; CONFIG register bit 0=1
     634C 8000 
1124 634E 0244  22         andi  tmp0,>7fff            ; Parameter value bit 0=0
     6350 7FFF 
1125 6352 C124  34 ldfnt1  mov   @tmp006(tmp0),tmp0    ; Load GROM index address ...
     6354 63B2 
1126 6356 0205  20         li    tmp1,tmp3hb           ; ... into register TMP3
     6358 830E 
1127 635A 0206  20         li    tmp2,2
     635C 0002 
1128 635E 06A0  32         bl    @xpyg2m               ; Get font table address
     6360 615C 
1129               *--------------------------------------------------------------
1130               * Setup GROM address
1131               *--------------------------------------------------------------
1132 6362 D807  38         movb  tmp3,@grmwa
     6364 9C02 
1133 6366 06C7  14         swpb  tmp3
1134 6368 D807  38         movb  tmp3,@grmwa           ; Setup GROM address for reading
     636A 9C02 
1135 636C C118  26         mov   *tmp4,tmp0            ; Get 1st parameter (VDP destination)
1136 636E 06A0  32         bl    @vdwa                 ; Setup VDP destination address
     6370 61F0 
1137 6372 05C8  14         inct  tmp4                  ; R11=R11+2
1138 6374 C158  26         mov   *tmp4,tmp1            ; Get font options into TMP1
1139 6376 0245  22         andi  tmp1,>7fff            ; Parameter value bit 0=0
     6378 7FFF 
1140 637A C1A5  34         mov   @tmp006+2(tmp1),tmp2  ; Get number of patterns to copy
     637C 63B4 
1141 637E C165  34         mov   @tmp006+4(tmp1),tmp1  ; 7 or 8 byte pattern ?
     6380 63B6 
1142               *--------------------------------------------------------------
1143               * Copy from GROM to VRAM
1144               *--------------------------------------------------------------
1145 6382 0B15  56 ldfnt2  src   tmp1,1                ; Carry set ?
1146 6384 1812  14         joc   ldfnt4                ; Yes, go insert a >00
1147 6386 D120  34         movb  @grmrd,tmp0
     6388 9800 
1148               *--------------------------------------------------------------
1149               *   Make font fat
1150               *--------------------------------------------------------------
1151 638A 2320  38         coc   @wbit0,config         ; Fat flag set ?
     638C 602A 
1152 638E 1603  14         jne   ldfnt3                ; No, so skip
1153 6390 D3C4  18         movb  tmp0,tmp6
1154 6392 091F  56         srl   tmp6,1
1155 6394 E10F  18         soc   tmp6,tmp0
1156               *-------------------------------------------------------------
1157               *   Dump byte to VDP and do housekeeping
1158               *--------------------------------------------------------------
1159 6396 D804  38 ldfnt3  movb  tmp0,@vdpw            ; Dump byte to VRAM
     6398 8C00 
1160 639A 0606  14         dec   tmp2
1161 639C 16F2  14         jne   ldfnt2
1162 639E 05C8  14         inct  tmp4                  ; R11=R11+2
1163 63A0 020F  20         li    r15,vdpw              ; Set VDP write address
     63A2 8C00 
1164 63A4 024C  22         andi  config,>7fff          ; CONFIG register bit 0=0
     63A6 7FFF 
1165 63A8 0458  20         b     *tmp4                 ; Exit
1166 63AA D820  54 ldfnt4  movb  @bd0,@vdpw            ; Insert byte >00 into VRAM
     63AC 604C 
     63AE 8C00 
1167 63B0 10E8  14         jmp   ldfnt2
1168 63B2 004C     tmp006  data  >004c,64*8,>0000      ; Pointer to TI title screen font
     63B4 0200 
     63B6 0000 
1169 63B8 004E             data  >004e,64*7,>0101      ; Pointer to upper case font
     63BA 01C0 
     63BC 0101 
1170 63BE 004E             data  >004e,96*7,>0101      ; Pointer to upper & lower case font
     63C0 02A0 
     63C2 0101 
1171 63C4 0050             data  >0050,32*7,>0101      ; Pointer to lower case font
     63C6 00E0 
     63C8 0101 
1172               
1173               
1174               ***************************************************************
1175               * Put length-byte prefixed string at current YX
1176               ***************************************************************
1177               *  BL   @PUTSTR
1178               *  DATA P0
1179               *
1180               *  P0 = Pointer to string
1181               *--------------------------------------------------------------
1182               *  REMARKS
1183               *  First byte of string must contain length
1184               ********@*****@*********************@**************************
1185 63CA C17B  30 putstr  mov   *r11+,tmp1
1186 63CC D1B5  28 xutst0  movb  *tmp1+,tmp2           ; Get length byte
1187 63CE C1CB  18 xutstr  mov   r11,tmp3
1188 63D0 06A0  32         bl    @yx2pnt               ; Get VDP destination address
     63D2 62BA 
1189 63D4 C2C7  18         mov   tmp3,r11
1190 63D6 0986  56         srl   tmp2,8                ; Right justify length byte
1191 63D8 0460  28         b     @xpym2v               ; Display string
     63DA 6114 
1192               
1193               
1194               ***************************************************************
1195               * Put length-byte prefixed string at YX
1196               ***************************************************************
1197               *  BL   @PUTAT
1198               *  DATA P0,P1
1199               *
1200               *  P0 = YX position
1201               *  P1 = Pointer to string
1202               *--------------------------------------------------------------
1203               *  REMARKS
1204               *  First byte of string must contain length
1205               ********@*****@*********************@**************************
1206 63DC C83B  50 putat   mov   *r11+,@wyx            ; Set YX position
     63DE 832A 
1207 63E0 0460  28         b     @putstr
     63E2 63CA 
1208               
1209               
1210               *//////////////////////////////////////////////////////////////
1211               *                   VDP hchar functions
1212               *//////////////////////////////////////////////////////////////
1216               
1217               *//////////////////////////////////////////////////////////////
1218               *                   VDP vchar functions
1219               *//////////////////////////////////////////////////////////////
1223               
1224               *//////////////////////////////////////////////////////////////
1225               *                    VDP box functions
1226               *//////////////////////////////////////////////////////////////
1230               
1231               *//////////////////////////////////////////////////////////////
1232               *                VDP unsigned numbers support
1233               *//////////////////////////////////////////////////////////////
1235                       copy  "vdp_numsupport.asm"
**** **** ****     > vdp_numsupport.asm
0001               * FILE......: vdp_numsupport.asm
0002               * Purpose...: VDP create, display numbers module
0003               
0004               ***************************************************************
0005               * MKNUM - Convert unsigned number to string
0006               ***************************************************************
0007               *  BL   @MKNUM
0008               *  DATA P0,P1,P2
0009               *
0010               *  P0   = Pointer to 16 bit unsigned number
0011               *  P1   = Pointer to 5 byte string buffer
0012               *  P2HB = Offset for ASCII digit
0013               *  P2LB = Character for replacing leading 0's
0014               *
0015               *  (CONFIG:0 = 1) = Display number at cursor YX
0016               ********@*****@*********************@**************************
0017 63E4 0207  20 mknum   li    tmp3,5                ; Digit counter
     63E6 0005 
0018 63E8 C17B  30         mov   *r11+,tmp1            ; \ Get 16 bit unsigned number
0019 63EA C155  26         mov   *tmp1,tmp1            ; /
0020 63EC C23B  30         mov   *r11+,tmp4            ; Pointer to string buffer
0021 63EE 0228  22         ai    tmp4,4                ; Get end of buffer
     63F0 0004 
0022 63F2 0206  20         li    tmp2,10               ; Divide by 10 to isolate last digit
     63F4 000A 
0023               *--------------------------------------------------------------
0024               *  Do string conversion
0025               *--------------------------------------------------------------
0026 63F6 04C4  14 mknum1  clr   tmp0                  ; Clear the high word of the dividend
0027 63F8 3D06  128         div   tmp2,tmp0             ; (TMP0:TMP1) / 10 (TMP2)
0028 63FA 06C5  14         swpb  tmp1                  ; Move to high-byte for writing to buffer
0029 63FC B15B  26         ab    *r11,tmp1             ; Add offset for ASCII digit
0030 63FE D605  30         movb  tmp1,*tmp4            ; Write remainder to string buffer
0031 6400 C144  18         mov   tmp0,tmp1             ; Move integer result into R4 for the next digit
0032 6402 0608  14         dec   tmp4                  ; Adjust string pointer for next digit
0033 6404 0607  14         dec   tmp3                  ; Decrease counter
0034 6406 16F7  14         jne   mknum1                ; Do next digit
0035               *--------------------------------------------------------------
0036               *  Replace leading 0's with fill character
0037               *--------------------------------------------------------------
0038 6408 0207  20         li    tmp3,4                ; Check first 4 digits
     640A 0004 
0039 640C 0588  14         inc   tmp4                  ; Too far, back to buffer start
0040 640E C11B  26         mov   *r11,tmp0
0041 6410 0A84  56         sla   tmp0,8                ; Only keep fill character in HB
0042 6412 96D8  38 mknum2  cb    *tmp4,*r11            ; Digit = 0 ?
0043 6414 1305  14         jeq   mknum4                ; Yes, replace with fill character
0044 6416 05CB  14 mknum3  inct  r11
0045 6418 2320  38         coc   @wbit0,config         ; Check if 'display' bit is set
     641A 602A 
0046 641C 1305  14         jeq   mknum5                ; Yes, so show at current YX position
0047 641E 045B  20         b     *r11                  ; Exit
0048 6420 DE04  32 mknum4  movb  tmp0,*tmp4+           ; Replace leading 0 with fill character
0049 6422 0607  14         dec   tmp3                  ; 4th digit processed ?
0050 6424 13F8  14         jeq   mknum3                ; Yes, exit
0051 6426 10F5  14         jmp   mknum2                ; No, next one
0052               *--------------------------------------------------------------
0053               *  Display integer on screen at current YX position
0054               *--------------------------------------------------------------
0055 6428 024C  22 mknum5  andi  config,>7fff          ; Reset bit 0
     642A 7FFF 
0056 642C C10B  18         mov   r11,tmp0
0057 642E 0224  22         ai    tmp0,-4
     6430 FFFC 
0058 6432 C154  26         mov   *tmp0,tmp1            ; Get buffer address
0059 6434 0206  20         li    tmp2,>0500            ; String length = 5
     6436 0500 
0060 6438 0460  28         b     @xutstr               ; Display string
     643A 63CE 
0061               
0062               
0063               ***************************************************************
0064               * PUTNUM - Put unsigned number on screen
0065               ***************************************************************
0066               *  BL   @PUTNUM
0067               *  DATA P0,P1,P2,P3
0068               *--------------------------------------------------------------
0069               *  P0   = YX position
0070               *  P1   = Pointer to 16 bit unsigned number
0071               *  P2   = Pointer to 5 byte string buffer
0072               *  P3HB = Offset for ASCII digit
0073               *  P3LB = Character for replacing leading 0's
0074               ********@*****@*********************@**************************
0075 643C C83B  50 putnum  mov   *r11+,@wyx            ; Set cursor
     643E 832A 
0076 6440 026C  22         ori   config,>8000          ; CONFIG register bit 0=1
     6442 8000 
0077 6444 10CF  14         jmp   mknum                 ; Convert number and display
**** **** ****     > runlib.asm
1237               
1238               *//////////////////////////////////////////////////////////////
1239               *                 VDP hex numbers support
1240               *//////////////////////////////////////////////////////////////
1244               
1245               *//////////////////////////////////////////////////////////////
1246               *                 VDP viewport functionality
1247               *//////////////////////////////////////////////////////////////
1251               
1252               
1253               *//////////////////////////////////////////////////////////////
1254               *                            SOUND
1255               *//////////////////////////////////////////////////////////////
1256               
1257               ***************************************************************
1258               * MUTE - Mute all sound generators
1259               ***************************************************************
1260               *  BL  @MUTE
1261               *  Mute sound generators and clear sound pointer
1262               *
1263               *  BL  @MUTE2
1264               *  Mute sound generators without clearing sound pointer
1265               ********@*****@*********************@**************************
1266 6446 04E0  34 mute    clr   @wsdlst               ; Clear sound pointer
     6448 8334 
1267 644A 4320  34 mute2   szc   @wbit13,config        ; Turn off/pause sound player
     644C 6044 
1268 644E 0204  20         li    tmp0,muttab
     6450 6460 
1269 6452 0205  20         li    tmp1,sound            ; Sound generator port >8400
     6454 8400 
1270 6456 D574  40         movb  *tmp0+,*tmp1          ; Generator 0
1271 6458 D574  40         movb  *tmp0+,*tmp1          ; Generator 1
1272 645A D574  40         movb  *tmp0+,*tmp1          ; Generator 2
1273 645C D554  38         movb  *tmp0,*tmp1           ; Generator 3
1274 645E 045B  20         b     *r11
1275 6460 9FBF     muttab  byte  >9f,>bf,>df,>ff       ; Table for muting all generators
     6462 DFFF 
1276               
1277               
1278               ***************************************************************
1279               * SDPREP - Prepare for playing sound
1280               ***************************************************************
1281               *  BL   @SDPREP
1282               *  DATA P0,P1
1283               *
1284               *  P0 = Address where tune is stored
1285               *  P1 = Option flags for sound player
1286               *--------------------------------------------------------------
1287               *  REMARKS
1288               *  Use the below equates for P1:
1289               *
1290               *  SDOPT1 => Tune is in CPU memory + loop
1291               *  SDOPT2 => Tune is in CPU memory
1292               *  SDOPT3 => Tune is in VRAM + loop
1293               *  SDOPT4 => Tune is in VRAM
1294               ********@*****@*********************@**************************
1295 6464 C81B  46 sdprep  mov   *r11,@wsdlst          ; Set tune address
     6466 8334 
1296 6468 C83B  50         mov   *r11+,@wsdtmp         ; Set tune address in temp
     646A 8336 
1297 646C 024C  22         andi  r12,>fff8             ; Clear bits 13-14-15
     646E FFF8 
1298 6470 E33B  30         soc   *r11+,config          ; Set options
1299 6472 D820  54         movb  @bd1,@r13lb           ; Set initial duration
     6474 604D 
     6476 831B 
1300 6478 045B  20         b     *r11
1301               
1302               ***************************************************************
1303               * SDPLAY - Sound player for tune in VRAM or CPU memory
1304               ***************************************************************
1305               *  BL  @SDPLAY
1306               *--------------------------------------------------------------
1307               *  REMARKS
1308               *  Set config register bit13=0 to pause player.
1309               *  Set config register bit14=1 to repeat (or play next tune).
1310               ********@*****@*********************@**************************
1311 647A 2320  38 sdplay  coc   @wbit13,config        ; Play tune ?
     647C 6044 
1312 647E 1301  14         jeq   sdpla1                ; Yes, play
1313 6480 045B  20         b     *r11
1314               *--------------------------------------------------------------
1315               * Initialisation
1316               *--------------------------------------------------------------
1317 6482 060D  14 sdpla1  dec   r13                   ; duration = duration - 1
1318 6484 9820  54         cb    @r13lb,@bd0           ; R13LB == 0 ?
     6486 831B 
     6488 604C 
1319 648A 1301  14         jeq   sdpla3                ; Play next note
1320 648C 045B  20 sdpla2  b     *r11                  ; Note still busy, exit
1321 648E 2320  38 sdpla3  coc   @wbit15,config        ; Play tune from CPU memory ?
     6490 6048 
1322 6492 131A  14         jeq   mmplay
1323               *--------------------------------------------------------------
1324               * Play tune from VDP memory
1325               *--------------------------------------------------------------
1326 6494 C120  34 vdplay  mov   @wsdtmp,tmp0          ; Get tune address
     6496 8336 
1327 6498 06C4  14         swpb  tmp0
1328 649A D804  38         movb  tmp0,@vdpa
     649C 8C02 
1329 649E 06C4  14         swpb  tmp0
1330 64A0 D804  38         movb  tmp0,@vdpa
     64A2 8C02 
1331 64A4 04C4  14         clr   tmp0
1332 64A6 D120  34         movb  @vdpr,tmp0            ; length = 0 (end of tune) ?
     64A8 8800 
1333 64AA 131E  14         jeq   sdexit                ; Yes. exit
1334 64AC 0984  56 vdpla1  srl   tmp0,8                ; Right justify length byte
1335 64AE A804  38         a     tmp0,@wsdtmp          ; Adjust for next table entry
     64B0 8336 
1336 64B2 D820  54 vdpla2  movb  @vdpr,@>8400          ; Feed byte to sound generator
     64B4 8800 
     64B6 8400 
1337 64B8 0604  14         dec   tmp0
1338 64BA 16FB  14         jne   vdpla2
1339 64BC D820  54         movb  @vdpr,@r13lb          ; Set duration counter
     64BE 8800 
     64C0 831B 
1340 64C2 05E0  34 vdpla3  inct  @wsdtmp               ; Adjust for next table entry, honour byte (1) + (n+1)
     64C4 8336 
1341 64C6 045B  20         b     *r11
1342               *--------------------------------------------------------------
1343               * Play tune from CPU memory
1344               *--------------------------------------------------------------
1345 64C8 C120  34 mmplay  mov   @wsdtmp,tmp0
     64CA 8336 
1346 64CC D174  28         movb  *tmp0+,tmp1           ; length = 0 (end of tune) ?
1347 64CE 130C  14         jeq   sdexit                ; Yes, exit
1348 64D0 0985  56 mmpla1  srl   tmp1,8                ; Right justify length byte
1349 64D2 A805  38         a     tmp1,@wsdtmp          ; Adjust for next table entry
     64D4 8336 
1350 64D6 D834  48 mmpla2  movb  *tmp0+,@>8400         ; Feed byte to sound generator
     64D8 8400 
1351 64DA 0605  14         dec   tmp1
1352 64DC 16FC  14         jne   mmpla2
1353 64DE D814  46         movb  *tmp0,@r13lb          ; Set duration counter
     64E0 831B 
1354 64E2 05E0  34         inct  @wsdtmp               ; Adjust for next table entry, honour byte (1) + (n+1)
     64E4 8336 
1355 64E6 045B  20         b     *r11
1356               *--------------------------------------------------------------
1357               * Exit. Check if tune must be looped
1358               *--------------------------------------------------------------
1359 64E8 2320  38 sdexit  coc   @wbit14,config        ; Loop flag set ?
     64EA 6046 
1360 64EC 1607  14         jne   sdexi2                ; No, exit
1361 64EE C820  54         mov   @wsdlst,@wsdtmp
     64F0 8334 
     64F2 8336 
1362 64F4 D820  54         movb  @bd1,@r13lb           ; Set initial duration
     64F6 604D 
     64F8 831B 
1363 64FA 045B  20 sdexi1  b     *r11                  ; Exit
1364 64FC 024C  22 sdexi2  andi  config,>fff8          ; Reset music player
     64FE FFF8 
1365 6500 045B  20         b     *r11                  ; Exit
1366               
1367               
1368               *//////////////////////////////////////////////////////////////
1369               *                            SPEECH
1370               *//////////////////////////////////////////////////////////////
1371               
1372               ***************************************************************
1373               * SPSTAT - Read status register byte from speech synthesizer
1374               ***************************************************************
1375               *  LI  TMP2,@>....
1376               *  B   @SPSTAT
1377               *--------------------------------------------------------------
1378               * REMARKS
1379               * Destroys R11 !
1380               *
1381               * Register usage
1382               * TMP0HB = Status byte read from speech synth
1383               * TMP1   = Temporary use  (scratchpad machine code)
1384               * TMP2   = Return address for this subroutine
1385               * R11    = Return address (scratchpad machine code)
1386               ********@*****@*********************@**************************
1387 6502 0204  20 spstat  li    tmp0,spchrd           ; (R4) = >9000
     6504 9000 
1388 6506 C820  54         mov   @spcode,@mcsprd       ; \
     6508 6074 
     650A 8322 
1389 650C C820  54         mov   @spcode+2,@mcsprd+2   ; / Load speech read code
     650E 6076 
     6510 8324 
1390 6512 020B  20         li    r11,spsta1            ; Return to SPSTA1
     6514 651A 
1391 6516 0460  28         b     @mcsprd               ; Run scratchpad code
     6518 8322 
1392 651A C820  54 spsta1  mov   @mccode,@mcsprd       ; \
     651C 606E 
     651E 8322 
1393 6520 C820  54         mov   @mccode+2,@mcsprd+2   ; / Restore tight loop code
     6522 6070 
     6524 8324 
1394 6526 0456  20         b     *tmp2                 ; Exit
1395               
1396               
1397               ***************************************************************
1398               * SPCONN - Check if speech synthesizer connected
1399               ***************************************************************
1400               * BL  @SPCONN
1401               *--------------------------------------------------------------
1402               * OUTPUT
1403               * TMP0HB = Byte read from speech synth
1404               *--------------------------------------------------------------
1405               * REMARKS
1406               * See Editor/Assembler manual, section 22.1.6 page 354.
1407               * Calls SPSTAT.
1408               *
1409               * Register usage
1410               * TMP0HB = Byte read from speech synth
1411               * TMP3   = Copy of R11
1412               * R12    = CONFIG register
1413               ********@*****@*********************@**************************
1414 6528 C1CB  18 spconn  mov   r11,tmp3              ; Save R11
1415               *--------------------------------------------------------------
1416               * Setup speech synthesizer memory address >0000
1417               *--------------------------------------------------------------
1418 652A 0204  20         li    tmp0,>4000            ; Load >40 (speech memory address command)
     652C 4000 
1419 652E 0205  20         li    tmp1,5                ; Process 5 nibbles in total
     6530 0005 
1420 6532 D804  38 spcon1  movb  tmp0,@spchwt          ; Write nibble >40 (5x)
     6534 9400 
1421 6536 0605  14         dec   tmp1
1422 6538 16FC  14         jne   spcon1
1423               *--------------------------------------------------------------
1424               * Read first byte from speech synthesizer memory address >0000
1425               *--------------------------------------------------------------
1426 653A 0204  20         li    tmp0,>1000
     653C 1000 
1427 653E D804  38         movb  tmp0,@spchwt          ; Load >10 (speech memory read command)
     6540 9400 
1428 6542 1000  14         nop                         ; \
1429 6544 1000  14         nop                         ; / 12 Microseconds delay
1430 6546 0206  20         li    tmp2,spcon2
     6548 654E 
1431 654A 0460  28         b     @spstat               ; Read status byte
     654C 6502 
1432               *--------------------------------------------------------------
1433               * Update status bit 10 in CONFIG register
1434               *--------------------------------------------------------------
1435 654E 0984  56 spcon2  srl   tmp0,8                ; MSB to LSB
1436 6550 0284  22         ci    tmp0,>00aa            ; >aa means speech found
     6552 00AA 
1437 6554 1603  14         jne   spcon3
1438 6556 026C  22         ori   config,>0020          ; Set config bit10=1
     6558 0020 
1439 655A 1002  14         jmp   spcon4
1440 655C 024C  22 spcon3  andi  config,>ffdf          ; Set config bit10=0
     655E FFDF 
1441 6560 0457  20 spcon4  b     *tmp3                 ; Exit
1442               
1443               ***************************************************************
1444               * SPPREP - Prepare for playing speech
1445               ***************************************************************
1446               *  BL   @SPPREP
1447               *  DATA P0,P1
1448               *
1449               *  P0 = Address of LPC data for external voice
1450               *       or index of word to speak if resident voice
1451               *  P1 = Option flags for speech player
1452               *--------------------------------------------------------------
1453               *  REMARKS
1454               *  Use the below equates for P1:
1455               *
1456               *  SPOPT1  => External voice
1457               *  SPOPT2  => Resident voice
1458               ********@*****@*********************@**************************
1459 6562 C83B  50 spprep  mov   *r11+,@wspeak         ; Set speech address
     6564 8338 
1460 6566 024C  22         andi  r12,>e3ff             ; Clear bits 3-4-5
     6568 E3FF 
1461 656A E33B  30         soc   *r11+,config          ; Set options
1462 656C 045B  20         b     *r11
1463               
1464               ***************************************************************
1465               * SPPLAY - Speech player
1466               ***************************************************************
1467               * BL  @SPPLAY
1468               *--------------------------------------------------------------
1469               * Register usage
1470               * TMP3   = Copy of R11
1471               * R12    = CONFIG register
1472               ********@*****@*********************@**************************
1473 656E 2720  38 spplay  czc   @wbit3,config         ; Player off ?
     6570 6030 
1474 6572 1332  14         jeq   spplaz                ; Yes, exit
1475 6574 C1CB  18 sppla1  mov   r11,tmp3              ; Save R11
1476 6576 2320  38         coc   @tmp010,config        ; Is on/busy/external ?
     6578 65DA 
1477 657A 1313  14         jeq   spkex3                ; Check FIFO buffer level
1478 657C 2320  38         coc   @wbit5,config         ; Start speak external ?
     657E 6034 
1479 6580 1300  14         jeq   spkext                ; Yes, do it
1480               *--------------------------------------------------------------
1481               * Speak resident: ****
1482               *--------------------------------------------------------------
1483               *       NOT   YET
1484               *--------------------------------------------------------------
1485               * Speak external: Push LPC data to speech synthesizer
1486               *--------------------------------------------------------------
1487 6582 C120  34 spkext  mov   @wspeak,tmp0
     6584 8338 
1488 6586 D834  48         movb  *tmp0+,@spchwt        ; Send byte to speech synth
     6588 9400 
1489 658A 1000  14         jmp   $+2                   ; Delay
1490 658C 0206  20         li    tmp2,16
     658E 0010 
1491 6590 D834  48 spkex1  movb  *tmp0+,@spchwt        ; Send byte to speech synth
     6592 9400 
1492 6594 0606  14         dec   tmp2
1493 6596 16FC  14         jne   spkex1
1494 6598 026C  22         ori   config,>1800          ; bit 4=1 (busy) & bit 5=1 (external)
     659A 1800 
1495 659C C804  38         mov   tmp0,@wspeak          ; Update LPC pointer
     659E 8338 
1496 65A0 101B  14         jmp   spplaz                ; Exit
1497               *--------------------------------------------------------------
1498               * Speak external: Check synth FIFO buffer level
1499               *--------------------------------------------------------------
1500 65A2 0206  20 spkex3  li    tmp2,spkex4           ; Set return address for SPSTAT
     65A4 65AA 
1501 65A6 0460  28         b     @spstat               ; Get speech FIFO buffer status
     65A8 6502 
1502 65AA 2120  38 spkex4  coc   @wh4000,tmp0          ; FIFO BL (buffer low) bit set ?
     65AC 602C 
1503 65AE 1301  14         jeq   spkex5                ; Yes, refill
1504 65B0 1013  14         jmp   spplaz                ; No, exit
1505               *--------------------------------------------------------------
1506               * Speak external: Refill synth with LPC data if FIFO buffer low
1507               *--------------------------------------------------------------
1508 65B2 C120  34 spkex5  mov   @wspeak,tmp0
     65B4 8338 
1509 65B6 0206  20         li    tmp2,8                ; Bytes to send to speech synth
     65B8 0008 
1510 65BA D174  28 spkex6  movb  *tmp0+,tmp1
1511 65BC D805  38         movb  tmp1,@spchwt          ; Send byte to speech synth
     65BE 9400 
1512 65C0 0285  22         ci    tmp1,spkoff           ; Speak off marker found ?
     65C2 FF00 
1513 65C4 1305  14         jeq   spkex8
1514 65C6 0606  14         dec   tmp2
1515 65C8 16F8  14         jne   spkex6                ; Send next byte
1516 65CA C804  38         mov   tmp0,@wspeak          ; Update LPC pointer
     65CC 8338 
1517 65CE 1004  14 spkex7  jmp   spplaz                ; Exit
1518               *--------------------------------------------------------------
1519               * Speak external: Done with speaking
1520               *--------------------------------------------------------------
1521 65D0 4320  34 spkex8  szc   @tmp010,config        ; bit 3,4,5=0
     65D2 65DA 
1522 65D4 04E0  34         clr   @wspeak               ; Reset pointer
     65D6 8338 
1523 65D8 0457  20 spplaz  b     *tmp3                 ; Exit
1524 65DA 1C00     tmp010  data  >1c00                 ; Binary 0001110000000000
1525               
1526               
1527               *//////////////////////////////////////////////////////////////
1528               *                           KEYBOARD
1529               *//////////////////////////////////////////////////////////////
1530               
1531               ***************************************************************
1532               * VIRTKB - Read virtual keyboard and joysticks
1533               ***************************************************************
1534               *  BL @VIRTKB
1535               *--------------------------------------------------------------
1536               *  COLUMN     0     1  2  3  4  5    6   7
1537               *         +---------------------------------+------+
1538               *  ROW 7  |   =     .  ,  M  N  /   JS1 JS2 | Fire |
1539               *  ROW 6  | SPACE   L  K  J  H  :;  JS1 JS2 | Left |
1540               *  ROW 5  | ENTER   O  I  U  Y  P   JS1 JS2 | Right|
1541               *  ROW 4  |         9  8  7  6  0   JS1 JS2 | Down |
1542               *  ROW 3  | FCTN    2  3  4  5  1   JS1 JS2 | Up   |
1543               *  ROW 2  | SHIFT   S  D  F  G  A           +------|
1544               *  ROW 1  | CTRL    W  E  R  T  Q                  |
1545               *  ROW 0  |         X  C  V  B  Z                  |
1546               *         +----------------------------------------+
1547               *  See MG smart programmer 1986
1548               *  September/Page 15 and November/Page 6
1549               *  Also see virtual keyboard status for bits to check
1550               *--------------------------------------------------------------
1551               *  Register usage
1552               *  TMP0     Keyboard matrix column to process
1553               *  TMP1MSB  Keyboard matrix 8 bits of 1 column
1554               *  TMP2     Virtual keyboard flags
1555               *  TMP3     Address of entry in mapping table
1556               *  TMP4     Copy of R12 (CONFIG REGISTER)
1557               *  R12      CRU communication
1558               ********@*****@*********************@**************************
1559 65DC 4320  34 virtkb  szc   @wbit11,config        ; Reset ANY key
     65DE 6040 
1560 65E0 C20C  18         mov   config,tmp4           ; Save R12 (CONFIG REGISTER)
1561 65E2 04C4  14         clr   tmp0                  ; Value in MSB! Start with column 0
1562 65E4 04C6  14         clr   tmp2                  ; Erase virtual keyboard flags
1563 65E6 0207  20         li    tmp3,kbmap0           ; Start with column 0
     65E8 6658 
1564               *--------------------------------------------------------------
1565               * Check alpha lock key
1566               *-------@-----@---------------------@--------------------------
1567 65EA 04CC  14         clr   r12
1568 65EC 1E15  20         sbz   >0015                 ; Set P5
1569 65EE 1F07  20         tb    7
1570 65F0 1302  14         jeq   virtk1
1571 65F2 0206  20         li    tmp2,kalpha           ; Alpha lock key down
     65F4 8000 
1572               *--------------------------------------------------------------
1573               * Scan keyboard matrix
1574               *-------@-----@---------------------@--------------------------
1575 65F6 1D15  20 virtk1  sbo   >0015                 ; Reset P5
1576 65F8 020C  20         li    r12,>0024             ; Scan full 8x8 keyboard matrix. R12 is used by LDCR
     65FA 0024 
1577 65FC 30C4  56         ldcr  tmp0,3                ; Set keyboard column with a value from 0-7 (3=3 bits)
1578 65FE 020C  20         li    r12,>0006             ; Load CRU base for row. R12 required by STCR
     6600 0006 
1579 6602 0705  14         seto  tmp1                  ; >FFFF
1580 6604 3605  64         stcr  tmp1,8                ; Bring 8 row bits into MSB of TMP1
1581 6606 0545  14         inv   tmp1
1582 6608 1302  14         jeq   virtk2                ; >0000 ?
1583 660A E220  34         soc   @wbit11,tmp4          ; Set ANY key in copy of CONFIG register
     660C 6040 
1584               *--------------------------------------------------------------
1585               * Process column
1586               *-------@-----@---------------------@--------------------------
1587 660E 2177  34 virtk2  coc   *tmp3+,tmp1           ; Check bit mask
1588 6610 1601  14         jne   virtk3
1589 6612 E197  26         soc   *tmp3,tmp2            ; Set virtual keyboard flags
1590 6614 05C7  14 virtk3  inct  tmp3
1591 6616 8817  46         c     *tmp3,@kbeoc          ; End-of-column ?
     6618 6664 
1592 661A 16F9  14         jne   virtk2                ; No, next entry
1593 661C 05C7  14         inct  tmp3
1594               *--------------------------------------------------------------
1595               * Prepare for next column
1596               *-------@-----@---------------------@--------------------------
1597 661E 0284  22 virtk4  ci    tmp0,>0700            ; Column 7 processed ?
     6620 0700 
1598 6622 1309  14         jeq   virtk6                ; Yes, exit
1599 6624 0284  22         ci    tmp0,>0200            ; Column 2 processed ?
     6626 0200 
1600 6628 1303  14         jeq   virtk5                ; Yes, skip
1601 662A 0224  22         ai    tmp0,>0100
     662C 0100 
1602 662E 10E3  14         jmp   virtk1
1603 6630 0204  20 virtk5  li    tmp0,>0500            ; Skip columns 3-4
     6632 0500 
1604 6634 10E0  14         jmp   virtk1
1605               *--------------------------------------------------------------
1606               * Exit
1607               *-------@-----@---------------------@--------------------------
1608 6636 C308  18 virtk6  mov   tmp4,config           ; Restore CONFIG register
1609 6638 C806  38         mov   tmp2,@wvrtkb          ; Save virtual keyboard flags
     663A 8332 
1610 663C 1601  14         jne   virtk7
1611 663E 045B  20         b     *r11                  ; Exit
1612 6640 0286  22 virtk7  ci    tmp2,>ffff            ; FCTN-QUIT pressed ?
     6642 FFFF 
1613 6644 1603  14         jne   virtk8                ; No
1614 6646 0701  14         seto  r1                    ; Set exit flag
1615 6648 0460  28         b     @runli1               ; Yes, reset computer
     664A 67C6 
1616 664C 0286  22 virtk8  ci    tmp2,kalpha           ; Only alpha-lock pressed ?
     664E 8000 
1617 6650 1602  14         jne   virtk9
1618 6652 4320  34         szc   @wbit11,config        ; Yes, so reset ANY key
     6654 6040 
1619 6656 045B  20 virtk9  b     *r11                  ; Exit
1620               *--------------------------------------------------------------
1621               * Mapping table
1622               *-------@-----@---------------------@--------------------------
1623               *                                   ; Bit 01234567
1624 6658 1100     kbmap0  data  >1100,>ffff           ; >11 00010001  FCTN QUIT
     665A FFFF 
1625 665C 0200             data  >0200,k1fire          ; >02 00000010  spacebar
     665E 0020 
1626 6660 0400             data  >0400,kenter          ; >04 00000100  enter
     6662 4000 
1627 6664 FFFF     kbeoc   data  >ffff
1628 6666 0800     kbmap1  data  >0800,kback           ; >08 00001000  FCTN BACK
     6668 1000 
1629 666A 2000             data  >2000,k1lf            ; >20 00100000  S (arrow left)
     666C 0200 
1630 666E 8000             data  >8000,k1dn            ; >80 10000000  X (arrow down)
     6670 0040 
1631 6672 FFFF             data  >ffff
1632 6674 0800     kbmap2  data  >0800,kredo           ; >08 00001000  FCTN REDO
     6676 2000 
1633 6678 2000             data  >2000,k1rg            ; >20 00100000  D (arrow right)
     667A 0100 
1634 667C 4000             data  >4000,k1up            ; >80 01000000  E (arrow up)
     667E 0080 
1635 6680 FFFF             data  >ffff
1636 6682 0800     kbcol5  data  >0800,kpause          ; >08 00001000  P (pause)
     6684 0800 
1637 6686 8000             data  >8000,k1fire          ; >80 01000000  Q (fire)
     6688 0020 
1638 668A FFFF             data  >ffff
1639 668C 0100     kbmap6  data  >0100,k1fire          ; >01 00000001  joystick 1 FIRE
     668E 0020 
1640 6690 0200             data  >0200,k1lf            ; >02 00000010  joystick 1 left
     6692 0200 
1641 6694 0400             data  >0400,k1rg            ; >04 00000100  joystick 1 right
     6696 0100 
1642 6698 0800             data  >0800,k1dn            ; >08 00001000  joystick 1 down
     669A 0040 
1643 669C 1000             data  >1000,k1up            ; >10 00010000  joystick 1 up
     669E 0080 
1644 66A0 FFFF             data  >ffff
1645 66A2 0100     kbmap7  data  >0100,k2fire          ; >01 00000001  joystick 2 FIRE
     66A4 0001 
1646 66A6 0200             data  >0200,k2lf            ; >02 00000010  joystick 2 left
     66A8 0010 
1647 66AA 0400             data  >0400,k2rg            ; >04 00000100  joystick 2 right
     66AC 0008 
1648 66AE 0800             data  >0800,k2dn            ; >08 00001000  joystick 2 down
     66B0 0002 
1649 66B2 1000             data  >1000,k2up            ; >10 00010000  joystick 2 up
     66B4 0004 
1650 66B6 FFFF             data  >ffff
1651               
1652               
1653               *//////////////////////////////////////////////////////////////
1654               *             Keyboard support (in real mode)
1655               *//////////////////////////////////////////////////////////////
1659               
1660               
1661               *//////////////////////////////////////////////////////////////
1662               *                            TIMERS
1663               *//////////////////////////////////////////////////////////////
1664               
1665               ***************************************************************
1666               * TMGR - X - Start Timer/Thread scheduler
1667               ***************************************************************
1668               *  B @TMGR
1669               *--------------------------------------------------------------
1670               *  REMARKS
1671               *  Timer/Thread scheduler. Normally called from MAIN.
1672               *  Don't forget to set BTIHI to highest slot in use.
1673               *
1674               *  Register usage in TMGR8 - TMGR11
1675               *  TMP0  = Pointer to timer table
1676               *  R10LB = Use as slot counter
1677               *  TMP2  = 2nd word of slot data
1678               *  TMP3  = Address of routine to call
1679               ********@*****@*********************@**************************
1680 66B8 0300  24 tmgr    limi  0                     ; No interrupt processing
     66BA 0000 
1681               *--------------------------------------------------------------
1682               * Read VDP status register
1683               *--------------------------------------------------------------
1684 66BC D360  34 tmgr1   movb  @vdps,r13             ; Save copy of VDP status register in R13
     66BE 8802 
1685               *--------------------------------------------------------------
1686               * Latch sprite collision flag
1687               *--------------------------------------------------------------
1688 66C0 2360  38         coc   @wbit2,r13            ; C flag on ?
     66C2 602E 
1689 66C4 1602  14         jne   tmgr1a                ; No, so move on
1690 66C6 E320  34         soc   @wbit12,config        ; Latch bit 12 in config register
     66C8 6042 
1691               *--------------------------------------------------------------
1692               * Interrupt flag
1693               *--------------------------------------------------------------
1694 66CA 2360  38 tmgr1a  coc   @wbit0,r13            ; Interupt flag set ?
     66CC 602A 
1695 66CE 1316  14         jeq   tmgr4                 ; Yes, process slots 0..n
1696               *--------------------------------------------------------------
1697               * Run speech player
1698               *--------------------------------------------------------------
1699 66D0 2320  38         coc   @wbit3,config         ; Speech player on ?
     66D2 6030 
1700 66D4 1602  14         jne   tmgr2
1701 66D6 06A0  32         bl    @sppla1               ; Run speech player
     66D8 6574 
1702               *--------------------------------------------------------------
1703               * Run kernel thread
1704               *--------------------------------------------------------------
1705 66DA 2320  38 tmgr2   coc   @wbit8,config         ; Kernel thread blocked ?
     66DC 603A 
1706 66DE 1305  14         jeq   tmgr3                 ; Yes, skip to user hook
1707 66E0 2320  38         coc   @wbit9,config         ; Kernel thread enabled ?
     66E2 603C 
1708 66E4 1602  14         jne   tmgr3                 ; No, skip to user hook
1709 66E6 0460  28         b     @kernel               ; Run kernel thread
     66E8 678C 
1710               *--------------------------------------------------------------
1711               * Run user hook
1712               *--------------------------------------------------------------
1713 66EA 2320  38 tmgr3   coc   @wbit6,config         ; User hook blocked ?
     66EC 6036 
1714 66EE 13E6  14         jeq   tmgr1
1715 66F0 2320  38         coc   @wbit7,config         ; User hook enabled ?
     66F2 6038 
1716 66F4 16E3  14         jne   tmgr1
1717 66F6 C120  34         mov   @wtiusr,tmp0
     66F8 832E 
1718 66FA 0454  20         b     *tmp0                 ; Run user hook
1719               *--------------------------------------------------------------
1720               * Do some internal housekeeping
1721               *--------------------------------------------------------------
1722 66FC 4320  34 tmgr4   szc   @tmdat,config         ; Unblock kernel thread and user hook
     66FE 675E 
1723 6700 C10A  18         mov   r10,tmp0
1724 6702 0244  22         andi  tmp0,>00ff            ; Clear HI byte
     6704 00FF 
1725 6706 2320  38         coc   @wbit2,config         ; PAL flag set ?
     6708 602E 
1726 670A 1303  14         jeq   tmgr5
1727 670C 0284  22         ci    tmp0,60               ; 1 second reached ?
     670E 003C 
1728 6710 1002  14         jmp   tmgr6
1729 6712 0284  22 tmgr5   ci    tmp0,50
     6714 0032 
1730 6716 1101  14 tmgr6   jlt   tmgr7                 ; No, continue
1731 6718 1001  14         jmp   tmgr8
1732 671A 058A  14 tmgr7   inc   r10                   ; Increase tick counter
1733               *--------------------------------------------------------------
1734               * Loop over slots
1735               *--------------------------------------------------------------
1736 671C C120  34 tmgr8   mov   @wtitab,tmp0          ; Pointer to timer table
     671E 832C 
1737 6720 024A  22         andi  r10,>ff00             ; Use R10LB as slot counter. Reset.
     6722 FF00 
1738 6724 C1D4  26 tmgr9   mov   *tmp0,tmp3            ; Is slot empty ?
1739 6726 1316  14         jeq   tmgr11                ; Yes, get next slot
1740               *--------------------------------------------------------------
1741               *  Check if slot should be executed
1742               *--------------------------------------------------------------
1743 6728 05C4  14         inct  tmp0                  ; Second word of slot data
1744 672A 0594  26         inc   *tmp0                 ; Update tick count in slot
1745 672C C194  26         mov   *tmp0,tmp2            ; Get second word of slot data
1746 672E 9820  54         cb    @tmp2hb,@tmp2lb       ; Slot target count = Slot internal counter ?
     6730 830C 
     6732 830D 
1747 6734 1608  14         jne   tmgr10                ; No, get next slot
1748 6736 0246  22         andi  tmp2,>ff00            ; Clear internal counter
     6738 FF00 
1749 673A C506  30         mov   tmp2,*tmp0            ; Update timer table
1750               *--------------------------------------------------------------
1751               *  Run slot, we only need TMP0 to survive
1752               *--------------------------------------------------------------
1753 673C C804  38         mov   tmp0,@wtitmp          ; Save TMP0
     673E 8330 
1754 6740 0697  24         bl    *tmp3                 ; Call routine in slot
1755 6742 C120  34 slotok  mov   @wtitmp,tmp0          ; Restore TMP0
     6744 8330 
1756               
1757               *--------------------------------------------------------------
1758               *  Prepare for next slot
1759               *--------------------------------------------------------------
1760 6746 058A  14 tmgr10  inc   r10                   ; Next slot
1761 6748 9820  54         cb    @r10lb,@btihi         ; Last slot done ?
     674A 8315 
     674C 8314 
1762 674E 1504  14         jgt   tmgr12                ; yes, Wait for next VDP interrupt
1763 6750 05C4  14         inct  tmp0                  ; Offset for next slot
1764 6752 10E8  14         jmp   tmgr9                 ; Process next slot
1765 6754 05C4  14 tmgr11  inct  tmp0                  ; Skip 2nd word of slot data
1766 6756 10F7  14         jmp   tmgr10                ; Process next slot
1767 6758 024A  22 tmgr12  andi  r10,>ff00             ; Use R10LB as tick counter. Reset.
     675A FF00 
1768 675C 10AF  14         jmp   tmgr1
1769 675E 0280     tmdat   data  >0280                 ; Bit 8 (kernel thread) and bit 6 (user hook)
1770               
1771               
1772               ***************************************************************
1773               * MKSLOT - Allocate timer slot(s)
1774               ***************************************************************
1775               *  BL    @MKSLOT
1776               *  BYTE  P0HB,P0LB
1777               *  DATA  P1
1778               *  ....
1779               *  DATA  EOL                        ; End-of-list
1780               *--------------------------------------------------------------
1781               *  P0 = Slot number, target count
1782               *  P1 = Subroutine to call via BL @xxxx if slot is fired
1783               ********@*****@*********************@**************************
1784 6760 C13B  30 mkslot  mov   *r11+,tmp0
1785 6762 C17B  30         mov   *r11+,tmp1
1786               *--------------------------------------------------------------
1787               *  Calculate address of slot
1788               *--------------------------------------------------------------
1789 6764 C184  18         mov   tmp0,tmp2
1790 6766 0966  56         srl   tmp2,6                ; Right align & TMP2 = TMP2 * 4
1791 6768 A1A0  34         a     @wtitab,tmp2          ; Add table base
     676A 832C 
1792               *--------------------------------------------------------------
1793               *  Add slot to table
1794               *--------------------------------------------------------------
1795 676C CD85  34         mov   tmp1,*tmp2+           ; Store address of subroutine
1796 676E 0A84  56         sla   tmp0,8                ; Get rid of slot number
1797 6770 C584  30         mov   tmp0,*tmp2            ; Store target count and reset tick count
1798               *--------------------------------------------------------------
1799               *  Check for end of list
1800               *--------------------------------------------------------------
1801 6772 881B  46         c     *r11,@whffff          ; End of list ?
     6774 604A 
1802 6776 1301  14         jeq   mkslo1                ; Yes, exit
1803 6778 10F3  14         jmp   mkslot                ; Process next entry
1804               *--------------------------------------------------------------
1805               *  Exit
1806               *--------------------------------------------------------------
1807 677A 05CB  14 mkslo1  inct  r11
1808 677C 045B  20         b     *r11                  ; Exit
1809               
1810               
1811               ***************************************************************
1812               * CLSLOT - Clear single timer slot
1813               ***************************************************************
1814               *  BL    @CLSLOT
1815               *  DATA  P0
1816               *--------------------------------------------------------------
1817               *  P0 = Slot number
1818               ********@*****@*********************@**************************
1819 677E C13B  30 clslot  mov   *r11+,tmp0
1820 6780 0A24  56 xlslot  sla   tmp0,2                ; TMP0 = TMP0*4
1821 6782 A120  34         a     @wtitab,tmp0          ; Add table base
     6784 832C 
1822 6786 04F4  30         clr   *tmp0+                ; Clear 1st word of slot
1823 6788 04D4  26         clr   *tmp0                 ; Clear 2nd word of slot
1824 678A 045B  20         b     *r11                  ; Exit
1825               
1826               
1827               ***************************************************************
1828               * KERNEL - The kernel thread
1829               *--------------------------------------------------------------
1830               *  REMARKS
1831               *  You shouldn't call the kernel thread manually.
1832               *  Instead control it via the CONFIG register.
1833               ********@*****@*********************@**************************
1834 678C E320  34 kernel  soc   @wbit8,config         ; Block kernel thread
     678E 603A 
1835 6790 2320  38         coc   @wbit13,config        ; Sound player on ?
     6792 6044 
1836 6794 1602  14         jne   kerne1
1837 6796 06A0  32         bl    @sdpla1               ; Run sound player
     6798 6482 
1838 679A 06A0  32 kerne1  bl    @virtkb               ; Scan virtual keyboard
     679C 65DC 
1844 679E 0460  28 kernez  b     @tmgr3                ; Exit
     67A0 66EA 
1845               
1846               
1847               
1848               ***************************************************************
1849               * MKHOOK - Allocate user hook
1850               ***************************************************************
1851               *  BL    @MKHOOK
1852               *  DATA  P0
1853               *--------------------------------------------------------------
1854               *  P0 = Address of user hook
1855               *--------------------------------------------------------------
1856               *  REMARKS
1857               *  The user hook gets executed after the kernel thread.
1858               *  The user hook must always exit with "B @HOOKOK"
1859               ********@*****@*********************@**************************
1860 67A2 C83B  50 mkhook  mov   *r11+,@wtiusr         ; Set user hook address
     67A4 832E 
1861 67A6 026C  22         ori   config,enusr          ; Enable user hook
     67A8 0100 
1862 67AA 045B  20 mkhoo1  b     *r11                  ; Return
1863      66BC     hookok  equ   tmgr1                 ; Exit point for user hook
1864               
1865               
1866               ***************************************************************
1867               * CLHOOK - Clear user hook
1868               ***************************************************************
1869               *  BL    @CLHOOK
1870               ********@*****@*********************@**************************
1871 67AC 04E0  34 clhook  clr   @wtiusr               ; Unset user hook address
     67AE 832E 
1872 67B0 024C  22         andi  config,>feff          ; Disable user hook (bit 7=0)
     67B2 FEFF 
1873 67B4 045B  20         b     *r11                  ; Return
1874               
1875               
1876               *//////////////////////////////////////////////////////////////
1877               *                       MISC FUNCTIONS
1878               *//////////////////////////////////////////////////////////////
1879               
1880               ***************************************************************
1881               * POPR. - Pop registers & return to caller
1882               ***************************************************************
1883               *  B  @POPRG.
1884               *--------------------------------------------------------------
1885               *  REMARKS
1886               *  R11 must be at stack bottom
1887               ********@*****@*********************@**************************
1888 67B6 C0F9  30 popr3   mov   *stack+,r3
1889 67B8 C0B9  30 popr2   mov   *stack+,r2
1890 67BA C079  30 popr1   mov   *stack+,r1
1891 67BC C039  30 popr0   mov   *stack+,r0
1892 67BE C2F9  30 poprt   mov   *stack+,r11
1893 67C0 045B  20         b     *r11
1894               
1895               *//////////////////////////////////////////////////////////////
1896               *                    RANDOM GENERATOR
1897               *//////////////////////////////////////////////////////////////
1901               
1902               
1903               *//////////////////////////////////////////////////////////////
1904               *                    RUNLIB INITIALISATION
1905               *//////////////////////////////////////////////////////////////
1906               
1907               ***************************************************************
1908               *  RUNLIB - Runtime library initalisation
1909               ***************************************************************
1910               *  B  @RUNLIB
1911               *--------------------------------------------------------------
1912               *  REMARKS
1913               *  If R1 in WS1 equals >FFFF we return to the TI title screen
1914               *  after clearing scratchpad memory.
1915               *  Use 'B @RUNLI1' to exit your program.
1916               ********@*****@*********************@**************************
1917 67C2 04E0  34 runlib  clr   @>8302                ; Reset exit flag (R1 in workspace WS1!)
     67C4 8302 
1918               *--------------------------------------------------------------
1919               * Alternative entry point
1920               *--------------------------------------------------------------
1921 67C6 0300  24 runli1  limi  0                     ; Turn off interrupts
     67C8 0000 
1922 67CA 02E0  18         lwpi  ws1                   ; Activate workspace 1
     67CC 8300 
1923 67CE C0E0  34         mov   @>83c0,r3             ; Get random seed from OS monitor
     67D0 83C0 
1924               
1925               *--------------------------------------------------------------
1926               * Clear scratch-pad memory from R4 upwards
1927               *--------------------------------------------------------------
1928 67D2 0202  20 runli2  li    r2,>8308
     67D4 8308 
1929 67D6 04F2  30 runli3  clr   *r2+                  ; Clear scratchpad >8306->83FF
1930 67D8 0282  22         ci    r2,>8400
     67DA 8400 
1931 67DC 16FC  14         jne   runli3
1932               *--------------------------------------------------------------
1933               * Exit to TI-99/4A title screen ?
1934               *--------------------------------------------------------------
1935 67DE 0281  22         ci    r1,>ffff              ; Exit flag set ?
     67E0 FFFF 
1936 67E2 1602  14         jne   runli4                ; No, continue
1937 67E4 0420  54         blwp  @0                    ; Yes, bye bye
     67E6 0000 
1938               *--------------------------------------------------------------
1939               * Determine if VDP is PAL or NTSC
1940               *--------------------------------------------------------------
1941 67E8 C803  38 runli4  mov   r3,@waux1             ; Store random seed
     67EA 833C 
1942 67EC 04C1  14         clr   r1                    ; Reset counter
1943 67EE 0202  20         li    r2,10                 ; We test 10 times
     67F0 000A 
1944 67F2 C0E0  34 runli5  mov   @vdps,r3
     67F4 8802 
1945 67F6 20E0  38         coc   @wbit0,r3             ; Interupt flag set ?
     67F8 602A 
1946 67FA 1302  14         jeq   runli6
1947 67FC 0581  14         inc   r1                    ; Increase counter
1948 67FE 10F9  14         jmp   runli5
1949 6800 0602  14 runli6  dec   r2                    ; Next test
1950 6802 16F7  14         jne   runli5
1951 6804 0281  22         ci    r1,>1250              ; Max for NTSC reached ?
     6806 1250 
1952 6808 1202  14         jle   runli7                ; No, so it must be NTSC
1953 680A 026C  22         ori   config,palon          ; Yes, it must be PAL, set flag
     680C 2000 
1954               *--------------------------------------------------------------
1955               * Prepare tight loop
1956               *--------------------------------------------------------------
1957 680E 06A0  32 runli7  bl    @cpym2m
     6810 60C4 
1958 6812 606E             data  mccode,mcloop+2,6     ; Copy machine code to scratchpad
     6814 8322 
     6816 0006 
1959               *--------------------------------------------------------------
1960               * Initialize registers, memory, ...
1961               *--------------------------------------------------------------
1962 6818 04C1  14 runli9  clr   r1
1963 681A 04C2  14         clr   r2
1964 681C 04C3  14         clr   r3
1965 681E 0209  20         li    stack,>8400           ; Set stack
     6820 8400 
1966 6822 020F  20         li    r15,vdpw              ; Set VDP write address
     6824 8C00 
1967 6826 06A0  32         bl    @mute                 ; Mute sound generators
     6828 6446 
1968               *--------------------------------------------------------------
1969               * Setup video memory
1970               *--------------------------------------------------------------
1971 682A 06A0  32         bl    @filv
     682C 609C 
1972 682E 0000             data  >0000,>00,16000       ; Clear VDP memory
     6830 0000 
     6832 3E80 
1973 6834 06A0  32         bl    @filv
     6836 609C 
1974 6838 0380             data  >0380,spfclr,16       ; Load color table
     683A 001C 
     683C 0010 
1975               *--------------------------------------------------------------
1976               * Check if there is a F18A present
1977               *--------------------------------------------------------------
1983               *--------------------------------------------------------------
1984               * Check if there is a speech synthesizer attached
1985               *--------------------------------------------------------------
1986 683E 06A0  32         bl    @spconn
     6840 6528 
1987               *--------------------------------------------------------------
1988               * Load video mode table & font
1989               *--------------------------------------------------------------
1990 6842 06A0  32 runlic  bl    @vidtab               ; Load video mode table into VDP
     6844 6222 
1991 6846 6058             data  spvmod                ; Equate selected video mode table
1992 6848 0204  20         li    tmp0,spfont           ; Get font option
     684A 000C 
1993 684C 0544  14         inv   tmp0                  ; NOFONT (>FFFF) specified ?
1994 684E 1304  14         jeq   runlid                ; Yes, skip it
1995 6850 06A0  32         bl    @ldfnt
     6852 633A 
1996 6854 0900             data  >0900,spfont          ; Load specified font
     6856 000C 
1997               *--------------------------------------------------------------
1998               * Branch to main program
1999               *--------------------------------------------------------------
2000 6858 026C  22 runlid  ori   config,enknl          ; Enable kernel thread
     685A 0040 
2001 685C 0460  28         b     @main                 ; Give control to main program
     685E 6860 
**** **** ****     > cpyrom.asm.578
0041               *--------------------------------------------------------------
0042               * SPECTRA2 startup options
0043               *--------------------------------------------------------------
0044      001C     spfclr  equ   >1C                   ; Foreground/Background color for font.
0045      000C     spfbck  equ   >0C                   ; Screen background color.
0046               *--------------------------------------------------------------
0047               * Variables
0048               *--------------------------------------------------------------
0049      83E0     timers  equ   >83e0                 ; Timer table (16 bytes/4 slots)
0050               ;--------------------------------------------------------------
0051               ; graphics mode 1 configuration (32x24)
0052               ;--------------------------------------------------------------
0053      6058     spvmod  equ   graph1                ; Video mode.   See VIDTAB for details.
0054      000C     spfont  equ   fnopt3                ; Font to load. See LDFONT for details.
0055               ***************************************************************
0056               * Main
0057               ********@*****@*********************@**************************
0058               main
0059 6860 06A0  32         bl    @cpym2m
     6862 60C4 
0060 6864 0000             data  >0000,>a000,>2000     ; Copy >2000 bytes from >0000 to >a0000.
     6866 A000 
     6868 2000 
0061               
0062 686A 06A0  32         bl    @putat
     686C 63DC 
0063 686E 0000             data  >0000,message
     6870 6876 
0064               
0065 6872 0460  28         b     @kernel
     6874 678C 
0066               
0067 6876 164F     message byte  22
0068 6877 ....             text  'OS ROM copied to >A000'
