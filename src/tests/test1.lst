XAS99 CROSS-ASSEMBLER   VERSION 1.7.0
**** **** ****     > test1.a99
0001               ***************************************************************
0002               * Hardware detection
0003               ***************************************************************
0004               * This file: hwdetect.a99
0005               ********|*****|*********************|**************************
0006                       save  >6000,>7fff
0007                       aorg  >6000
0008               
0009               *--------------------------------------------------------------
0010               * Cartridge header
0011               *--------------------------------------------------------------
0012 6000 AA01     grmhdr  byte  >aa,1,1,0,0,0
     6002 0100 
     6004 0000 
0013 6006 6010             data  prog0
0014 6008 0000             byte  0,0,0,0,0,0,0,0
     600A 0000 
     600C 0000 
     600E 0000 
0015 6010 0000     prog0   data  0                     ; No more items following
0016 6012 6C76             data  runlib
0017 6014 0946     title0  byte  9
0018 6015 ....             text  'F18A DEMO'
0019               *--------------------------------------------------------------
0020               * Include required files
0021               *--------------------------------------------------------------
0022                       copy  "../runlib.a99"
**** **** ****     > runlib.a99
0001               *******************************************************************************
0002               *              ___  ____  ____  ___  ____  ____    __    ___
0003               *             / __)(  _ \( ___)/ __)(_  _)(  _ \  /__\  (__ \
0004               *             \__ \ )___/ )__)( (__   )(   )   / /(__)\  / _/
0005               *             (___/(__)  (____)\___) (__) (_)\_)(__)(__)(____)
0006               *
0007               *                 TMS9900 Monitor & Arcade Game Library
0008               *                                for
0009               *                   the Texas Instruments TI-99/4A
0010               *
0011               *                    2010-2017 by Filip Van Vooren
0012               *
0013               *              https://github.com/FilipVanVooren/spectra2.git
0014               *******************************************************************************
0015               * Credits
0016               *     1) Speech code based on version of Mark Wills
0017               *     2) Number conversion based on work of Mathew Hagerty
0018               *     3) Bold font style based on work of sometimes99er
0019               *******************************************************************************
0020               * This file: runlib.a99
0021               *******************************************************************************
0022               * v1.2    2017/..   Work-in-Progress
0023               *         Change    Removed use of config bit 1 in MKHEX subroutine
0024               *         Change    Removed OS v2.2 check (config bit 10) and repurpose bit 10.
0025               *                   Check if speech synthesizer present upon startup.
0026               *         New       Check if F18A present upon startup (config bit 1)
0027               *         Change    Started refactoring runlib.a99 into multiple files
0028               *         Change    Repurpose bit 1 in CONFIG register from subroutine state
0029               *                   flag 1 to F18A present flag
0030               *         Change    Converted source from upper case to lower case
0031               *         New       F18A support routines (detect, 80 cols, ...)
0032               *         Bug-fix   Removed 6 years-old bug!
0033               *                   Overflow in calculation of X in YX2PNT routine
0034               *                   resulted in wrong VDP target address.
0035               *------------------------------------------------------------------------------
0036               * v1.1    2011/05   This version was never officially released
0037               *                   but contains many changes and some new functions.
0038               *
0039               *         Bug-fix   by TREV2005. Fixed YX2PYX register issue
0040               *         Change    Introduced memory location @WCOLMN and rewrote YX2PNT
0041               *                   for using MPY instruction.
0042               *                   Adjusted format of video mode table to include number
0043               *                   of columns per row.
0044               *                   VIDTAB subroutine adjusted as well.
0045               *         Change    Removed subroutine GTCLMN. The functionality is replaced
0046               *                   by the @WCOLMN memory location.
0047               *         New       Added subroutine SCRDIM for setting base and
0048               *                   width of a virtual screen.
0049               *         Change    Introduced memory locations WAUX1,WAUX2,WAUX3.
0050               *         Change    PUTBOX completely rewritten, now supports repeating
0051               *                   vertically and/or horizontally.
0052               *                   This is how its supposed to work from day one..
0053               *                   WARNING PUTBOX is not compatible with V1.
0054               *                   width & height swapped in P1.
0055               *         Change    Removed memory location WSEED.
0056               *                   On startup value is in WAUX1.
0057               *                   Added parameter P1 to RND subroutine (address random seed)
0058               *         Change    Modified FILBOX subroutine. Width and height swapped
0059               *                   in P1 so that it's the same as for PUTBOX subroutine.
0060               *         New       Added VIEW subroutine. This is a viewport into
0061               *                   a virtual screen.
0062               *         New       Added RLE2V subroutine.
0063               *                   Decompress RLE (Run Length Encoded data) to VRAM.
0064               *------------------------------------------------------------------------------
0065               * v1.0    2011/02   Initial version
0066               *******************************************************************************
0067               
0068               
0069               *//////////////////////////////////////////////////////////////
0070               *                       RUNLIB MEMORY SETUP
0071               *//////////////////////////////////////////////////////////////
0072               
0073               ***************************************************************
0074               * >8300 - >8341     Scratchpad memory layout (66 bytes)
0075               ********|*****|*********************|**************************
0076      8300     ws1     equ   >8300                 ; 32 - Primary workspace
0077      8320     mcloop  equ   >8320                 ; 08 - Machine code for loop & speech
0078      8328     wbase   equ   >8328                 ; 02 - PNT base address
0079      832A     wyx     equ   >832a                 ; 02 - Cursor YX position
0080      832C     wtitab  equ   >832c                 ; 02 - Timers: Address of timer table
0081      832E     wtiusr  equ   >832e                 ; 02 - Timers: Address of user hook
0082      8330     wtitmp  equ   >8330                 ; 02 - Timers: Internal use
0083      8332     wvrtkb  equ   >8332                 ; 02 - Virtual keyboard flags
0084      8334     wsdlst  equ   >8334                 ; 02 - Sound player: Tune address
0085      8336     wsdtmp  equ   >8336                 ; 02 - Sound player: Temporary use
0086      8338     wspeak  equ   >8338                 ; 02 - Speech player: Address of LPC data
0087      833A     wcolmn  equ   >833a                 ; 02 - Screen size, columns per row
0088      833C     waux1   equ   >833c                 ; 02 - Temporary storage 1
0089      833E     waux2   equ   >833e                 ; 02 - Temporary storage 2
0090      8340     waux3   equ   >8340                 ; 02 - Temporary storage 3
0091               ***************************************************************
0092      832A     by      equ   wyx                   ;      Cursor Y position
0093      832B     bx      equ   wyx+1                 ;      Cursor X position
0094      8322     mcsprd  equ   mcloop+2              ;      Speech read routine
0095               ***************************************************************
0096               * Register usage
0097               * R0-R3   General purpose registers
0098               * R4-R8   Temporary registers
0099               * R9      Stack pointer
0100               * R10     Highest slot in use + Timer counter
0101               * R11     Subroutine return address
0102               * R12     Configuration register
0103               * R13     Copy of VDP status byte and counter for sound player
0104               * R14     Copy of VDP register #0 and VDP register #1 bytes
0105               * R15     VDP read/write address
0106               ***************************************************************
0107               * Workspace and register equates
0108               ********|*****|*********************|**************************
0109      0000     r0      equ   0
0110      0001     r1      equ   1
0111      0002     r2      equ   2
0112      0003     r3      equ   3
0113      0004     r4      equ   4
0114      0005     r5      equ   5
0115      0006     r6      equ   6
0116      0007     r7      equ   7
0117      0008     r8      equ   8
0118      0009     r9      equ   9
0119      000A     r10     equ   10
0120      000B     r11     equ   11
0121      000C     r12     equ   12
0122      000D     r13     equ   13
0123      000E     r14     equ   14
0124      000F     r15     equ   15
0125      8300     r0hb    equ   ws1                   ; HI byte R0
0126      8301     r0lb    equ   ws1+1                 ; LO byte R0
0127      8302     r1hb    equ   ws1+2                 ; HI byte R1
0128      8303     r1lb    equ   ws1+3                 ; LO byte R1
0129      8304     r2hb    equ   ws1+4                 ; HI byte R2
0130      8305     r2lb    equ   ws1+5                 ; LO byte R2
0131      8306     r3hb    equ   ws1+6                 ; HI byte R3
0132      8307     r3lb    equ   ws1+7                 ; LO byte R3
0133      8308     r4hb    equ   ws1+8                 ; HI byte R4
0134      8309     r4lb    equ   ws1+9                 ; LO byte R4
0135      830A     r5hb    equ   ws1+10                ; HI byte R5
0136      830B     r5lb    equ   ws1+11                ; LO byte R5
0137      830C     r6hb    equ   ws1+12                ; HI byte R6
0138      830D     r6lb    equ   ws1+13                ; LO byte R6
0139      830E     r7hb    equ   ws1+14                ; HI byte R7
0140      830F     r7lb    equ   ws1+15                ; LO byte R7
0141      8310     r8hb    equ   ws1+16                ; HI byte R8
0142      8311     r8lb    equ   ws1+17                ; LO byte R8
0143      8312     r9hb    equ   ws1+18                ; HI byte R9
0144      8313     r9lb    equ   ws1+19                ; LO byte R9
0145      8314     r10hb   equ   ws1+20                ; HI byte R10
0146      8315     r10lb   equ   ws1+21                ; LO byte R10
0147      8316     r11hb   equ   ws1+22                ; HI byte R11
0148      8317     r11lb   equ   ws1+23                ; LO byte R11
0149      8318     r12hb   equ   ws1+24                ; HI byte R12
0150      8319     r12lb   equ   ws1+25                ; LO byte R12
0151      831A     r13hb   equ   ws1+26                ; HI byte R13
0152      831B     r13lb   equ   ws1+27                ; LO byte R13
0153      831C     r14hb   equ   ws1+28                ; HI byte R14
0154      831D     r14lb   equ   ws1+29                ; LO byte R14
0155      831E     r15hb   equ   ws1+30                ; HI byte R15
0156      831F     r15lb   equ   ws1+31                ; LO byte R15
0157      0004     tmp0    equ   r4                    ; Temp register 0
0158      0005     tmp1    equ   r5                    ; Temp register 1
0159      0006     tmp2    equ   r6                    ; Temp register 2
0160      0007     tmp3    equ   r7                    ; Temp register 3
0161      0008     tmp4    equ   r8                    ; Temp register 4
0162      0009     tmp5    equ   r9                    ; Temp register 5
0163      000F     tmp6    equ   r15                   ; Temp register 6
0164      8308     tmp0hb  equ   ws1+8                 ; HI byte R4
0165      8309     tmp0lb  equ   ws1+9                 ; LO byte R4
0166      830A     tmp1hb  equ   ws1+10                ; HI byte R5
0167      830B     tmp1lb  equ   ws1+11                ; LO byte R5
0168      830C     tmp2hb  equ   ws1+12                ; HI byte R6
0169      830D     tmp2lb  equ   ws1+13                ; LO byte R6
0170      830E     tmp3hb  equ   ws1+14                ; HI byte R7
0171      830F     tmp3lb  equ   ws1+15                ; LO byte R7
0172      8310     tmp4hb  equ   ws1+16                ; HI byte R8
0173      8311     tmp4lb  equ   ws1+17                ; LO byte R8
0174      8310     tmp5hb  equ   ws1+16                ; HI byte R8
0175      8311     tmp5lb  equ   ws1+17                ; LO byte R8
0176      831E     tmp6hb  equ   ws1+30                ; HI byte R15
0177      831F     tmp6lb  equ   ws1+31                ; LO byte R15
0178               ***************************************************************
0179               * Equates for VDP, GROM, SOUND, SPEECH ports
0180               ********|*****|*********************|**************************
0181      8400     sound   equ   >8400                 ; Sound generator address
0182      8800     vdpr    equ   >8800                 ; VDP read data window address
0183      8C00     vdpw    equ   >8c00                 ; VDP write data window address
0184      8802     vdps    equ   >8802                 ; VDP status register
0185      8C02     vdpa    equ   >8c02                 ; VDP address register
0186      9C02     grmwa   equ   >9c02                 ; GROM set write address
0187      9802     grmra   equ   >9802                 ; GROM set read address
0188      9800     grmrd   equ   >9800                 ; GROM read byte
0189      9C00     grmwd   equ   >9c00                 ; GROM write byte
0190      9000     spchrd  equ   >9000                 ; Address of speech synth Read Data Register
0191      9400     spchwt  equ   >9400                 ; Address of speech synth Write Data Register
0192               ***************************************************************
0193               * Equates for registers
0194               ********|*****|*********************|**************************
0195      0009     stack   equ   r9                    ; Stack pointer
0196      8314     btihi   equ   ws1+20                ; Highest slot in use (HI byte R10)
0197      000C     config  equ   r12                   ; SPECTRA configuration register
0198      831A     bvdpst  equ   ws1+26                ; Copy of VDP status register (HI byte R13)
0199      000E     vdpr01  equ   r14                   ; Copy of VDP#0 and VDP#1 bytes
0200      831C     vdpr0   equ   ws1+28                ; High byte of R14. Is VDP#0 byte
0201      831D     vdpr1   equ   ws1+29                ; Low byte  of R14. Is VDP#1 byte
0202      000F     vdprw   equ   r15                   ; Contains VDP read/write address
0203               ***************************************************************
0204               * Equates for memory locations
0205               ********|*****|*********************|**************************
0206      832E     wramf   equ   >832e                 ; Memory location F
0207      8338     wramk   equ   >8338                 ; Memory location K
0208      833A     wraml   equ   >833a                 ; Memory location L
0209               ***************************************************************
0210               * The config register equates
0211               *--------------------------------------------------------------
0212               * Configuration flags
0213               * ===================
0214               *
0215               * ; 15  Sound player: tune source       1=ROM/RAM      0=VDP MEMORY
0216               * ; 14  Sound player: repeat tune       1=yes          0=no
0217               * ; 13  Sound player: enabled           1=yes          0=no (or pause)
0218               * ; 12  Keyboard: mode                  1=real         0=virtual
0219               * ; 11  Keyboard: ANY key pressed       1=yes          0=no
0220               * ; 10  Speech Synthesizer present      1=yes          0=no
0221               * ; 09  Timer: Kernel thread enabled    1=yes          0=no
0222               * ; 08  Timer: Block kernel thread      1=yes          0=no
0223               * ; 07  Timer: User hook enabled        1=yes          0=no
0224               * ; 06  Timer: Block user hook          1=yes          0=no
0225               * ; 05  speech player: external voice   1=yes          0=no
0226               * ; 04  Speech player: busy             1=yes          0=no
0227               * ; 03  Speech player: enabled          1=yes          0=no
0228               * ; 02  VDP9918 PAL version             1=yes(50)      0=no(60)
0229               * ; 01  F18A present                    1=on           0=off
0230               * ; 00  Subroutine state flag           1=on           0=off
0231               ********|*****|*********************|**************************
0232      2000     palon   equ   >2000                 ; bit 2=1   (VDP9918 PAL version)
0233      0100     enusr   equ   >0100                 ; bit 7=1   (Enable user hook)
0234      0040     enknl   equ   >0040                 ; bit 9=1   (Enable kernel thread)
0235      0020     tms5200 equ   >0020                 ; bit 10=1  (Speech Synthesizer present)
0236               ***************************************************************
0237               * Subroutine parameter equates
0238               ***************************************************************
0239      FFFF     eol     equ   >ffff                 ; End-Of-List
0240      FFFF     nofont  equ   >ffff                 ; Skip loading font in RUNLIB
0241      0000     norep   equ   0                     ; PUTBOX > Value for P3. Don't repeat box
0242      3030     num1    equ   >3030                 ; MKNUM  > ASCII 0-9, leading 0's
0243      3020     num2    equ   >3020                 ; MKNUM  > ASCII 0-9, leading spaces
0244      0007     sdopt1  equ   7                     ; SDPLAY > 111 (Player on, repeat, tune in CPU memory)
0245      0005     sdopt2  equ   5                     ; SDPLAY > 101 (Player on, no repeat, tune in CPU memory)
0246      0006     sdopt3  equ   6                     ; SDPLAY > 110 (Player on, repeat, tune in VRAM)
0247      0004     sdopt4  equ   4                     ; SDPLAY > 100 (Player on, no repeat, tune in VRAM)
0248      0000     fnopt1  equ   >0000                 ; LDFNT  > Load TI title screen font
0249      0006     fnopt2  equ   >0006                 ; LDFNT  > Load upper case font
0250      000C     fnopt3  equ   >000c                 ; LDFNT  > Load upper/lower case font
0251      0012     fnopt4  equ   >0012                 ; LDFNT  > Load lower case font
0252      8000     fnopt5  equ   >8000                 ; LDFNT  > Load TI title screen font  & bold
0253      8006     fnopt6  equ   >8006                 ; LDFNT  > Load upper case font       & bold
0254      800C     fnopt7  equ   >800c                 ; LDFNT  > Load upper/lower case font & bold
0255      8012     fnopt8  equ   >8012                 ; LDFNT  > Load lower case font       & bold
0256               *--------------------------------------------------------------
0257               *   Speech player
0258               *--------------------------------------------------------------
0259      1400     spopt1  equ   >1400                 ; 0001010000000000 (Player on, external voice)
0260      1000     spopt2  equ   >1000                 ; 0001000000000000 (Player on, resident voice)
0261      0060     talkon  equ   >60                   ; 'start talking' command code for speech synth
0262      00FF     talkof  equ   >ff                   ; 'stop talking' command code for speech synth
0263      6000     spkon   equ   >6000                 ; 'start talking' command code for speech synth
0264      FF00     spkoff  equ   >ff00                 ; 'stop talking' command code for speech synth
0265               ***************************************************************
0266               * Virtual keyboard equates
0267               ***************************************************************
0268               * bit  0: ALPHA LOCK down             0=no  1=yes
0269               * bit  1: ENTER                       0=no  1=yes
0270               * bit  2: REDO                        0=no  1=yes
0271               * bit  3: BACK                        0=no  1=yes
0272               * bit  4: Pause                       0=no  1=yes
0273               * bit  5: *free*                      0=no  1=yes
0274               * bit  6: P1 Left                     0=no  1=yes
0275               * bit  7: P1 Right                    0=no  1=yes
0276               * bit  8: P1 Up                       0=no  1=yes
0277               * bit  9: P1 Down                     0=no  1=yes
0278               * bit 10: P1 Space / fire / Q         0=no  1=yes
0279               * bit 11: P2 Left                     0=no  1=yes
0280               * bit 12: P2 Right                    0=no  1=yes
0281               * bit 13: P2 Up                       0=no  1=yes
0282               * bit 14: P2 Down                     0=no  1=yes
0283               * bit 15: P2 Space / fire / Q         0=no  1=yes
0284               ***************************************************************
0285      8000     kalpha  equ   >8000                 ; Virtual key alpha lock
0286      4000     kenter  equ   >4000                 ; Virtual key enter
0287      2000     kredo   equ   >2000                 ; Virtual key REDO
0288      1000     kback   equ   >1000                 ; Virtual key BACK
0289      0800     kpause  equ   >0800                 ; Virtual key pause
0290      0400     kfree   equ   >0400                 ; ***NOT USED YET***
0291               *--------------------------------------------------------------
0292               * Keyboard Player 1
0293               *--------------------------------------------------------------
0294      0280     k1uplf  equ   >0280                 ; Virtual key up   + left
0295      0180     k1uprg  equ   >0180                 ; Virtual key up   + right
0296      0240     k1dnlf  equ   >0240                 ; Virtual key down + left
0297      0140     k1dnrg  equ   >0140                 ; Virtual key down + right
0298      0200     k1lf    equ   >0200                 ; Virtual key left
0299      0100     k1rg    equ   >0100                 ; Virtual key right
0300      0080     k1up    equ   >0080                 ; Virtual key up
0301      0040     k1dn    equ   >0040                 ; Virtual key down
0302      0020     k1fire  equ   >0020                 ; Virtual key fire
0303               *--------------------------------------------------------------
0304               * Keyboard Player 2
0305               *--------------------------------------------------------------
0306      0014     k2uplf  equ   >0014                 ; Virtual key up   + left
0307      000C     k2uprg  equ   >000c                 ; Virtual key up   + right
0308      0012     k2dnlf  equ   >0012                 ; Virtual key down + left
0309      000A     k2dnrg  equ   >000a                 ; Virtual key down + right
0310      0010     k2lf    equ   >0010                 ; Virtual key left
0311      0008     k2rg    equ   >0008                 ; Virtual key right
0312      0004     k2up    equ   >0004                 ; Virtual key up
0313      0002     k2dn    equ   >0002                 ; Virtual key down
0314      0001     k2fire  equ   >0001                 ; Virtual key fire
0315                       even
0316               
0317               
0318               ***************************************************************
0319               * Bank switch routine
0320               ***************************************************************
0321               
0322               ***************************************************************
0323               * SWBNK - Switch ROM bank
0324               ***************************************************************
0325               *  BL   @SWBNK
0326               *  DATA P0,P1
0327               *--------------------------------------------------------------
0328               *  P0 = Bank selection address (>600X)
0329               *  P1 = Vector address
0330               *--------------------------------------------------------------
0331               *  B    @SWBNKX
0332               *
0333               *  TMP0 = Bank selection address (>600X)
0334               *  TMP1 = Vector address
0335               *--------------------------------------------------------------
0336               *  Important! The bank-switch routine must be at the exact
0337               *  same location accross banks
0338               ********|*****|*********************|**************************
0339 601E C13B  30 swbnk   mov   *r11+,tmp0
0340 6020 C17B  30         mov   *r11+,tmp1
0341 6022 04D4  26 swbnkx  clr   *tmp0                 ; Select bank in TMP0
0342 6024 C155  26         mov   *tmp1,tmp1
0343 6026 0455  20         b     *tmp1                 ; Switch to routine in TMP1
0344               
0345               
0346               ***************************************************************
0347               *                      Some constants
0348               ********|*****|*********************|**************************
0349 6028 8000     wbit0   data  >8000                 ; Binary 1000000000000000
0350 602A 4000     wbit1   data  >4000                 ; Binary 0100000000000000
0351 602C 2000     wbit2   data  >2000                 ; Binary 0010000000000000
0352 602E 1000     wbit3   data  >1000                 ; Binary 0001000000000000
0353 6030 0800     wbit4   data  >0800                 ; Binary 0000100000000000
0354 6032 0400     wbit5   data  >0400                 ; Binary 0000010000000000
0355 6034 0200     wbit6   data  >0200                 ; Binary 0000001000000000
0356 6036 0100     wbit7   data  >0100                 ; Binary 0000000100000000
0357 6038 0080     wbit8   data  >0080                 ; Binary 0000000010000000
0358 603A 0040     wbit9   data  >0040                 ; Binary 0000000001000000
0359 603C 0020     wbit10  data  >0020                 ; Binary 0000000000100000
0360 603E 0010     wbit11  data  >0010                 ; Binary 0000000000010000
0361 6040 0008     wbit12  data  >0008                 ; Binary 0000000000001000
0362 6042 0004     wbit13  data  >0004                 ; Binary 0000000000000100
0363 6044 0002     wbit14  data  >0002                 ; Binary 0000000000000010
0364 6046 0001     wbit15  data  >0001                 ; Binary 0000000000000001
0365 6048 FFFF     whffff  data  >ffff                 ; Binary 1111111111111111
0366 604A 0001     bd0     byte  0                     ; Digit 0
0367               bd1     byte  1                     ; Digit 1
0368 604C 0203     bd2     byte  2                     ; Digit 2
0369               bd3     byte  3                     ; Digit 3
0370 604E 0405     bd4     byte  4                     ; Digit 4
0371               bd5     byte  5                     ; Digit 5
0372 6050 0607     bd6     byte  6                     ; Digit 6
0373               bd7     byte  7                     ; Digit 7
0374 6052 0809     bd8     byte  8                     ; Digit 8
0375               bd9     byte  9                     ; Digit 9
0376 6054 D000     bd208   byte  208                   ; Digit 208 (>D0)
0377                       even
0378               *--------------------------------------------------------------
0379               * Equates for constants
0380               *--------------------------------------------------------------
0381      603E     anykey  equ   wbit11                ; BIT 11 in the CONFIG register
0382      6028     bbit0   equ   wbit0
0383      602A     bbit1   equ   wbit1
0384      602C     bbit2   equ   wbit2
0385      602E     bbit3   equ   wbit3
0386      6030     bbit4   equ   wbit4
0387      6032     bbit5   equ   wbit5
0388      6034     bbit6   equ   wbit6
0389      6036     bbit7   equ   wbit7
0390      603F     bh10    equ   wbit11+1              ; >10
0391      603D     bh20    equ   wbit10+1              ; >20
0392      603B     bh40    equ   wbit9+1               ; >40
0393      6039     bh80    equ   wbit8+1               ; >80
0394      6046     wd1     equ   wbit15                ; >0001
0395      603C     wh20    equ   wbit10                ; >0020
0396      603A     wh40    equ   wbit9                 ; >0040
0397      6038     wh80    equ   wbit8                 ; >0080
0398      6036     wh100   equ   wbit7                 ; >0100
0399      602A     wh4000  equ   wbit1                 ; >4000
0400               
0401               
0402               ***************************************************************
0403               *                Data used by runtime library
0404               ********|*****|*********************|**************************
0405                       copy  "sp2vidmod.a99"       ; Videomode Tables
**** **** ****     > sp2vidmod.a99
0001               * FILE......: sp2vidmod.a99
0002               * Purpose...: Video mode tables
0003               
0004               *//////////////////////////////////////////////////////////////
0005               *                    Video mode tables
0006               *//////////////////////////////////////////////////////////////
0007               
0008               ***************************************************************
0009               * Graphics mode 1 (32 columns/24 rows)
0010               *--------------------------------------------------------------
0011 6056 00E2     graph1  byte  >00,>e2,>00,>0e,>01,>06,>02,SPFBCK,0,32
     6058 000E 
     605A 0106 
     605C 0201 
     605E 0020 
0012               * ; VDP#0 Control bits
0013               * ;      bit 6=0: M3 | Graphics 1 mode
0014               * ;      bit 7=0: Disable external VDP input
0015               * ; VDP#1 Control bits
0016               * ;      bit 0=1: 16K selection
0017               * ;      bit 1=1: Enable display
0018               * ;      bit 2=1: Enable VDP interrupt
0019               * ;      bit 3=0: M1 \ Graphics 1 mode
0020               * ;      bit 4=0: M2 /
0021               * ;      bit 5=0: reserved
0022               * ;      bit 6=1: 16x16 sprites
0023               * ;      bit 7=0: Sprite magnification (1x)
0024               * ; VDP#2 PNT (Pattern name table)       at >0000  (>00 * >400)
0025               * ; VDP#3 PCT (Pattern color table)      at >0380  (>0E * >040)
0026               * ; VDP#4 PDT (Pattern descriptor table) at >0800  (>01 * >800)
0027               * ; VDP#5 SAT (sprite attribute list)    at >0300  (>06 * >080)
0028               * ; VDP#6 SPT (Sprite pattern table)     at >1000  (>02 * >800)
0029               * ; VDP#7 Set screen background color
0030               ***************************************************************
0031               * Textmode (40 columns/24 rows)
0032               *--------------------------------------------------------------
0033 6060 00F2     tx4024  byte  >00,>f2,>00,>0e,>01,>06,>00,SPFCLR,0,40
     6062 000E 
     6064 0106 
     6066 00F5 
     6068 0028 
0034               * ; VDP#0 Control bits
0035               * ;      bit 6=0: M3 | Graphics 1 mode
0036               * ;      bit 7=0: Disable external VDP input
0037               * ; VDP#1 Control bits
0038               * ;      bit 0=1: 16K selection
0039               * ;      bit 1=1: Enable display
0040               * ;      bit 2=1: Enable VDP interrupt
0041               * ;      bit 3=1: M1 \ TEXT MODE
0042               * ;      bit 4=0: M2 /
0043               * ;      bit 5=0: reserved
0044               * ;      bit 6=1: 16x16 sprites
0045               * ;      bit 7=0: Sprite magnification (1x)
0046               * ; VDP#2 PNT (Pattern name table)       at >0000  (>00 * >400)
0047               * ; VDP#3 PCT (Pattern color table)      at >0380  (>0E * >040)
0048               * ; VDP#4 PDT (Pattern descriptor table) at >0800  (>01 * >800)
0049               * ; VDP#5 SAT (sprite attribute list)    at >0300  (>06 * >080)
0050               * ; VDP#6 SPT (Sprite pattern table)     at >0000  (>00 * >800)
0051               * ; VDP#7 Set foreground/background color
0052               ***************************************************************
0053               * Textmode (80 columns/24 rows) - F18A/9938
0054               *--------------------------------------------------------------
0055 606A 04F0     tx8024  byte  >04,>f0,>00,>1e,>01,>30,>02,SPFCLR,0,80
     606C 001E 
     606E 0130 
     6070 02F5 
     6072 0050 
0056               * ; VDP#0 Control bits
0057               * ;      bit 6=0: M3 | Graphics 1 mode
0058               * ;      bit 7=0: Disable external VDP input
0059               * ; VDP#1 Control bits
0060               * ;      bit 0=1: 16K selection
0061               * ;      bit 1=1: Enable display
0062               * ;      bit 2=1: Enable VDP interrupt
0063               * ;      bit 3=1: M1 \ TEXT MODE
0064               * ;      bit 4=0: M2 /
0065               * ;      bit 5=0: reserved
0066               * ;      bit 6=0: 8x8 sprites
0067               * ;      bit 7=0: Sprite magnification (1x)
0068               * ; VDP#2 PNT (Pattern name table)       at >0000  (>00 * >400)
0069               * ; VDP#3 PCT (Pattern color table)      at >0780  (>1E * >040)
0070               * ; VDP#4 PDT (Pattern descriptor table) at >0800  (>01 * >800)
0071               * ; VDP#5 SAT (sprite attribute list)    at >1800  (>30 * >080)
0072               * ; VDP#6 SPT (Sprite pattern table)     at >1000  (>02 * >800)
0073               * ; VDP#7 Set foreground/background color
0074               ***************************************************************
0075               * Textmode (80 columns/31 rows) - F18A
0076               *--------------------------------------------------------------
0077 6074 04F0     tx8031  byte  >04,>f0,>00,>1e,>01,>30,>02,SPFCLR,0,80
     6076 001E 
     6078 0130 
     607A 02F5 
     607C 0050 
0078               * ; VDP#0 Control bits
0079               * ;      bit 6=0: M3 | Graphics 1 mode
0080               * ;      bit 7=0: Disable external VDP input
0081               * ; VDP#1 Control bits
0082               * ;      bit 0=1: 16K selection
0083               * ;      bit 1=1: Enable display
0084               * ;      bit 2=1: Enable VDP interrupt
0085               * ;      bit 3=1: M1 \ TEXT MODE
0086               * ;      bit 4=0: M2 /
0087               * ;      bit 5=0: reserved
0088               * ;      bit 6=0: 8x8 sprites
0089               * ;      bit 7=0: Sprite magnification (1x)
0090               * ; VDP#2 PNT (Pattern name table)       at >0000  (>00 * >400)
0091               * ; VDP#3 PCT (Pattern color table)      at >0780  (>1E * >040)
0092               * ; VDP#4 PDT (Pattern descriptor table) at >0800  (>01 * >800)
0093               * ; VDP#5 SAT (sprite attribute list)    at >1800  (>30 * >080)
**** **** ****     > runlib.a99
0406 607E 6C22     kdata   data  kernel                ; Address of kernel thread
0407               *--------------------------------------------------------------
0408               * ; Machine code for tight loop.
0409               * ; The MOV operation at MCLOOP must be injected by the calling routine.
0410               *--------------------------------------------------------------
0411               *       DATA  >????                 ; \ MCLOOP  MOV   ...
0412 6080 0606     mccode  data  >0606                 ; |         DEC   R6 (TMP2)
0413 6082 16FD             data  >16fd                 ; |         JNE   MCLOOP
0414 6084 045B             data  >045b                 ; /         B     *R11
0415               *--------------------------------------------------------------
0416               * ; Machine code for reading from the speech synthesizer
0417               * ; The SRC instruction takes 12 uS for execution in scratchpad RAM.
0418               * ; Is required for the 12 uS delay. It destroys R5.
0419               *--------------------------------------------------------------
0420 6086 D114     spcode  data  >d114                 ; \         MOVB  *R4,R4 (TMP0)
0421 6088 0BC5             data  >0bc5                 ; /         SRC   R5,12  (TMP1)
0422                       even
0423               
0424               
0425               *//////////////////////////////////////////////////////////////
0426               *                     FILL & COPY FUNCTIONS
0427               *//////////////////////////////////////////////////////////////
0428               
0429               
0430               
0431               ***************************************************************
0432               * FILM - Fill CPU memory with byte
0433               ***************************************************************
0434               *  BL   @FILM
0435               *  DATA P0,P1,P2
0436               *--------------------------------------------------------------
0437               *  P0 = Memory start address
0438               *  P1 = Byte to fill
0439               *  P2 = Number of bytes to fill
0440               *--------------------------------------------------------------
0441               *  BL   @XFILM
0442               *
0443               *  TMP0 = Memory start address
0444               *  TMP1 = Byte to fill
0445               *  TMP2 = Number of bytes to fill
0446               ********|*****|*********************|**************************
0447 608A C13B  30 film    mov   *r11+,tmp0            ; Memory start
0448 608C C17B  30         mov   *r11+,tmp1            ; Byte to fill
0449 608E C1BB  30         mov   *r11+,tmp2            ; Repeat count
0450               *--------------------------------------------------------------
0451               * Fill memory with 16 bit words
0452               *--------------------------------------------------------------
0453 6090 C1C6  18 xfilm   mov   tmp2,tmp3
0454 6092 0247  22         andi  tmp3,1                ; TMP3=1 -> ODD else EVEN
     6094 0001 
0455               
0456 6096 1301  14         jeq   film1
0457 6098 0606  14         dec   tmp2                  ; Make TMP2 even
0458 609A D820  54 film1   movb  @tmp1lb,@tmp1hb       ; Duplicate value
     609C 830B 
     609E 830A 
0459 60A0 CD05  34 film2   mov   tmp1,*tmp0+
0460 60A2 0646  14         dect  tmp2
0461 60A4 16FD  14         jne   film2
0462               *--------------------------------------------------------------
0463               * Fill last byte if ODD
0464               *--------------------------------------------------------------
0465 60A6 C1C7  18         mov   tmp3,tmp3
0466 60A8 1301  14         jeq   filmz
0467 60AA D505  30         movb  tmp1,*tmp0
0468 60AC 045B  20 filmz   b     *r11
0469               
0470               
0471               ***************************************************************
0472               * FILV - Fill VRAM with byte
0473               ***************************************************************
0474               *  BL   @FILV
0475               *  DATA P0,P1,P2
0476               *--------------------------------------------------------------
0477               *  P0 = VDP start address
0478               *  P1 = Byte to fill
0479               *  P2 = Number of bytes to fill
0480               *--------------------------------------------------------------
0481               *  BL   @XFILV
0482               *
0483               *  TMP0 = VDP start address
0484               *  TMP1 = Byte to fill
0485               *  TMP2 = Number of bytes to fill
0486               ********|*****|*********************|**************************
0487 60AE C13B  30 filv    mov   *r11+,tmp0            ; Memory start
0488 60B0 C17B  30         mov   *r11+,tmp1            ; Byte to fill
0489 60B2 C1BB  30         mov   *r11+,tmp2            ; Repeat count
0490               *--------------------------------------------------------------
0491               *    Setup VDP write address
0492               *--------------------------------------------------------------
0493 60B4 0264  22 xfilv   ori   tmp0,>4000
     60B6 4000 
0494 60B8 06C4  14         swpb  tmp0
0495 60BA D804  38         movb  tmp0,@vdpa
     60BC 8C02 
0496 60BE 06C4  14         swpb  tmp0
0497 60C0 D804  38         movb  tmp0,@vdpa
     60C2 8C02 
0498               *--------------------------------------------------------------
0499               *    Fill bytes in VDP memory
0500               *--------------------------------------------------------------
0501 60C4 020F  20         li    r15,vdpw              ; Set VDP write address
     60C6 8C00 
0502 60C8 06C5  14         swpb  tmp1
0503 60CA C820  54         mov   @filzz,@mcloop        ; Setup move command
     60CC 60D4 
     60CE 8320 
0504 60D0 0460  28         b     @mcloop               ; Write data to VDP
     60D2 8320 
0505 60D4 D7C5     filzz   data  >d7c5                 ; MOVB TMP1,*R15
0506               
0507               
0508               ***************************************************************
0509               * CPYM2M - Copy CPU memory to CPU memory
0510               ***************************************************************
0511               *  BL   @CPYM2M
0512               *  DATA P0,P1,P2
0513               *--------------------------------------------------------------
0514               *  P0 = Memory source address
0515               *  P1 = Memory target address
0516               *  P2 = Number of bytes to copy
0517               *--------------------------------------------------------------
0518               *  BL @XPYM2M
0519               *
0520               *  TMP0 = Memory source address
0521               *  TMP1 = Memory target address
0522               *  TMP2 = Number of bytes to copy
0523               ********|*****|*********************|**************************
0524 60D6 C13B  30 cpym2m  mov   *r11+,tmp0            ; Memory source address
0525 60D8 C17B  30         mov   *r11+,tmp1            ; Memory target address
0526 60DA C1BB  30         mov   *r11+,tmp2            ; Number of bytes to copy
0527               *--------------------------------------------------------------
0528               * Do some checks first
0529               *--------------------------------------------------------------
0530 60DC 024C  22 xpym2m  andi  config,>7fff          ; Clear CONFIG bit 0
     60DE 7FFF 
0531 60E0 C1C4  18         mov   tmp0,tmp3
0532 60E2 0247  22         andi  tmp3,1
     60E4 0001 
0533 60E6 1618  14         jne   cpyodd                ; Odd source address handling
0534 60E8 C1C5  18 cpym1   mov   tmp1,tmp3
0535 60EA 0247  22         andi  tmp3,1
     60EC 0001 
0536 60EE 1614  14         jne   cpyodd                ; Odd target address handling
0537               *--------------------------------------------------------------
0538               * 8 bit copy
0539               *--------------------------------------------------------------
0540 60F0 2320  38 cpym2   coc   @wbit0,config         ; CONFIG bit 0 set ?
     60F2 6028 
0541 60F4 1605  14         jne   cpym3
0542 60F6 C820  54         mov   @tmp011,@mcloop       ; Setup byte copy command
     60F8 611E 
     60FA 8320 
0543 60FC 0460  28         b     @mcloop               ; Copy memory and exit
     60FE 8320 
0544               *--------------------------------------------------------------
0545               * 16 bit copy
0546               *--------------------------------------------------------------
0547 6100 C1C6  18 cpym3   mov   tmp2,tmp3
0548 6102 0247  22         andi  tmp3,1                ; TMP3=1 -> ODD else EVEN
     6104 0001 
0549 6106 1301  14         jeq   cpym4
0550 6108 0606  14         dec   tmp2                  ; Make TMP2 even
0551 610A CD74  46 cpym4   mov   *tmp0+,*tmp1+
0552 610C 0646  14         dect  tmp2
0553 610E 16FD  14         jne   cpym4
0554               *--------------------------------------------------------------
0555               * Copy last byte if ODD
0556               *--------------------------------------------------------------
0557 6110 C1C7  18         mov   tmp3,tmp3
0558 6112 1301  14         jeq   cpymz
0559 6114 D554  38         movb  *tmp0,*tmp1
0560 6116 045B  20 cpymz   b     *r11
0561               *--------------------------------------------------------------
0562               * Handle odd source/target address
0563               *--------------------------------------------------------------
0564 6118 026C  22 cpyodd  ori   config,>8000        ; Set CONFIG bot 0
     611A 8000 
0565 611C 10E9  14         jmp   cpym2
0566 611E DD74     tmp011  data  >dd74               ; MOVB *TMP0+,*TMP1+
0567               
0568               
0569               ***************************************************************
0570               * CPYM2V - Copy CPU memory to VRAM
0571               ***************************************************************
0572               *  BL   @CPYM2V
0573               *  DATA P0,P1,P2
0574               *--------------------------------------------------------------
0575               *  P0 = VDP start address
0576               *  P1 = RAM/ROM start address
0577               *  P2 = Number of bytes to copy
0578               *--------------------------------------------------------------
0579               *  BL @XPYM2V
0580               *
0581               *  TMP0 = VDP start address
0582               *  TMP1 = RAM/ROM start address
0583               *  TMP2 = Number of bytes to copy
0584               ********|*****|*********************|**************************
0585 6120 C13B  30 cpym2v  mov   *r11+,tmp0            ; VDP Start address
0586 6122 C17B  30         mov   *r11+,tmp1            ; RAM/ROM start address
0587 6124 C1BB  30         mov   *r11+,tmp2            ; Bytes to copy
0588               *--------------------------------------------------------------
0589               *    Setup VDP write address
0590               *--------------------------------------------------------------
0591 6126 0264  22 xpym2v  ori   tmp0,>4000
     6128 4000 
0592 612A 06C4  14         swpb  tmp0
0593 612C D804  38         movb  tmp0,@vdpa
     612E 8C02 
0594 6130 06C4  14         swpb  tmp0
0595 6132 D804  38         movb  tmp0,@vdpa
     6134 8C02 
0596               *--------------------------------------------------------------
0597               *    Copy bytes from CPU memory to VRAM
0598               *--------------------------------------------------------------
0599 6136 020F  20         li    r15,vdpw              ; Set VDP write address
     6138 8C00 
0600 613A C820  54         mov   @tmp008,@mcloop       ; Setup copy command
     613C 6144 
     613E 8320 
0601 6140 0460  28         b     @mcloop               ; Write data to VDP
     6142 8320 
0602 6144 D7F5     tmp008  data  >d7f5                 ; MOVB *TMP1+,*R15
0603               
0604               
0605               ***************************************************************
0606               * CPYV2M - Copy VRAM to CPU memory
0607               ***************************************************************
0608               *  BL   @CPYV2M
0609               *  DATA P0,P1,P2
0610               *--------------------------------------------------------------
0611               *  P0 = VDP source address
0612               *  P1 = RAM target address
0613               *  P2 = Number of bytes to copy
0614               *--------------------------------------------------------------
0615               *  BL @XPYV2M
0616               *
0617               *  TMP0 = VDP source address
0618               *  TMP1 = RAM target address
0619               *  TMP2 = Number of bytes to copy
0620               ********|*****|*********************|**************************
0621 6146 C13B  30 cpyv2m  mov   *r11+,tmp0            ; VDP source address
0622 6148 C17B  30         mov   *r11+,tmp1            ; Target address in RAM
0623 614A C1BB  30         mov   *r11+,tmp2            ; Bytes to copy
0624               *--------------------------------------------------------------
0625               *    Setup VDP read address
0626               *--------------------------------------------------------------
0627 614C 06C4  14 xpyv2m  swpb  tmp0
0628 614E D804  38         movb  tmp0,@vdpa
     6150 8C02 
0629 6152 06C4  14         swpb  tmp0
0630 6154 D804  38         movb  tmp0,@vdpa
     6156 8C02 
0631               *--------------------------------------------------------------
0632               *    Copy bytes from VDP memory to RAM
0633               *--------------------------------------------------------------
0634 6158 020F  20         li    r15,vdpr              ; Set VDP read address
     615A 8800 
0635 615C C820  54         mov   @tmp007,@mcloop       ; Setup copy command
     615E 6166 
     6160 8320 
0636 6162 0460  28         b     @mcloop               ; Read data from VDP
     6164 8320 
0637 6166 DD5F     tmp007  data  >dd5f                 ; MOVB *R15,*TMP+
0638               
0639               
0640               ***************************************************************
0641               * CPYG2M - Copy GROM memory to CPU memory
0642               ***************************************************************
0643               *  BL   @CPYG2M
0644               *  DATA P0,P1,P2
0645               *--------------------------------------------------------------
0646               *  P0 = GROM source address
0647               *  P1 = CPU target address
0648               *  P2 = Number of bytes to copy
0649               *--------------------------------------------------------------
0650               *  BL @CPYG2M
0651               *
0652               *  TMP0 = GROM source address
0653               *  TMP1 = CPU target address
0654               *  TMP2 = Number of bytes to copy
0655               ********|*****|*********************|**************************
0656 6168 C13B  30 cpyg2m  mov   *r11+,tmp0            ; Memory source address
0657 616A C17B  30         mov   *r11+,tmp1            ; Memory target address
0658 616C C1BB  30         mov   *r11+,tmp2            ; Number of bytes to copy
0659               *--------------------------------------------------------------
0660               * Setup GROM source address
0661               *--------------------------------------------------------------
0662 616E D804  38 xpyg2m  movb  tmp0,@grmwa
     6170 9C02 
0663 6172 06C4  14         swpb  tmp0
0664 6174 D804  38         movb  tmp0,@grmwa
     6176 9C02 
0665               *--------------------------------------------------------------
0666               *    Copy bytes from GROM to CPU memory
0667               *--------------------------------------------------------------
0668 6178 0204  20         li    tmp0,grmrd            ; Set TMP0 to GROM data port
     617A 9800 
0669 617C C820  54         mov   @tmp003,@mcloop       ; Setup copy command
     617E 6186 
     6180 8320 
0670 6182 0460  28         b     @mcloop               ; Copy bytes
     6184 8320 
0671 6186 DD54     tmp003  data  >dd54                 ; MOVB *TMP0,*TMP1+
0672               
0673               
0674               ***************************************************************
0675               * CPYG2V - Copy GROM memory to VRAM memory
0676               ***************************************************************
0677               *  BL   @CPYG2V
0678               *  DATA P0,P1,P2
0679               *--------------------------------------------------------------
0680               *  P0 = GROM source address
0681               *  P1 = VDP target address
0682               *  P2 = Number of bytes to copy
0683               *--------------------------------------------------------------
0684               *  BL @CPYG2V
0685               *
0686               *  TMP0 = GROM source address
0687               *  TMP1 = VDP target address
0688               *  TMP2 = Number of bytes to copy
0689               ********|*****|*********************|**************************
0690 6188 C13B  30 cpyg2v  mov   *r11+,tmp0            ; Memory source address
0691 618A C17B  30         mov   *r11+,tmp1            ; Memory target address
0692 618C C1BB  30         mov   *r11+,tmp2            ; Number of bytes to copy
0693               *--------------------------------------------------------------
0694               * Setup GROM source address
0695               *--------------------------------------------------------------
0696 618E D804  38 xpyg2v  movb  tmp0,@grmwa
     6190 9C02 
0697 6192 06C4  14         swpb  tmp0
0698 6194 D804  38         movb  tmp0,@grmwa
     6196 9C02 
0699               *--------------------------------------------------------------
0700               * Setup VDP target address
0701               *--------------------------------------------------------------
0702 6198 0265  22         ori   tmp1,>4000
     619A 4000 
0703 619C 06C5  14         swpb  tmp1
0704 619E D805  38         movb  tmp1,@vdpa
     61A0 8C02 
0705 61A2 06C5  14         swpb  tmp1
0706 61A4 D805  38         movb  tmp1,@vdpa            ; Set VDP target address
     61A6 8C02 
0707               *--------------------------------------------------------------
0708               *    Copy bytes from GROM to VDP memory
0709               *--------------------------------------------------------------
0710 61A8 0207  20         li    tmp3,grmrd            ; Set TMP3 to GROM data port
     61AA 9800 
0711 61AC 020F  20         li    r15,vdpw              ; Set VDP write address
     61AE 8C00 
0712 61B0 C820  54         mov   @tmp002,@mcloop       ; Setup copy command
     61B2 61BA 
     61B4 8320 
0713 61B6 0460  28         b     @mcloop               ; Copy bytes
     61B8 8320 
0714 61BA D7D7     tmp002  data  >d7d7                 ; MOVB *TMP3,*R15
0715               
0716               
0717               ***************************************************************
0718               * RLE2V - RLE decompress to VRAM memory
0719               ***************************************************************
0720               *  BL   @RLE2V
0721               *  DATA P0,P1,P2
0722               *--------------------------------------------------------------
0723               *  P0 = ROM/RAM source address
0724               *  P1 = VDP target address
0725               *  P2 = Length of RLE encoded data
0726               *--------------------------------------------------------------
0727               *  BL @RLE2VX
0728               *
0729               *  TMP0     = VDP target address
0730               *  TMP2 (!) = ROM/RAM source address
0731               *  TMP3 (!) = Length of RLE encoded data
0732               *--------------------------------------------------------------
0733               *  Detail on RLE compression format:
0734               *  - If high bit is set, remaining 7 bits indicate to copy
0735               *    the next byte that many times.
0736               *  - If high bit is clear, remaining 7 bits indicate how many
0737               *    data bytes (non-repeated) follow.
0738               ********|*****|*********************|**************************
0739 61BC C1BB  30 rle2v   mov   *r11+,tmp2            ; ROM/RAM source address
0740 61BE C13B  30         mov   *r11+,tmp0            ; VDP target address
0741 61C0 C1FB  30         mov   *r11+,tmp3            ; Length of RLE encoded data
0742 61C2 C80B  38         mov   r11,@waux1            ; Save return address
     61C4 833C 
0743 61C6 06A0  32 rle2vx  bl    @vdwa                 ; Setup VDP address from TMP0
     61C8 6202 
0744 61CA C106  18         mov   tmp2,tmp0             ; We can safely reuse TMP0 now
0745 61CC D1B4  28 rle2v0  movb  *tmp0+,tmp2           ; Get control byte into TMP2
0746 61CE 0607  14         dec   tmp3                  ; Update length
0747 61D0 1314  14         jeq   rle2vz                ; End of list
0748 61D2 0A16  56         sla   tmp2,1                ; Check bit 0 of control byte
0749 61D4 1808  14         joc   rle2v2                ; Yes, next byte is compressed
0750               *--------------------------------------------------------------
0751               *    Dump uncompressed bytes
0752               *--------------------------------------------------------------
0753 61D6 C820  54 rle2v1  mov   @rledat,@mcloop       ; Setup machine code (MOVB *TMP0+,*R15)
     61D8 6200 
     61DA 8320 
0754 61DC 0996  56         srl   tmp2,9                ; Use control byte as counter
0755 61DE 61C6  18         s     tmp2,tmp3             ; Update length
0756 61E0 06A0  32         bl    @mcloop               ; Write data to VDP
     61E2 8320 
0757 61E4 1008  14         jmp   rle2v3
0758               *--------------------------------------------------------------
0759               *    Dump compressed bytes
0760               *--------------------------------------------------------------
0761 61E6 C820  54 rle2v2  mov   @filzz,@mcloop        ; Setup machine code(MOVB TMP1,*R15)
     61E8 60D4 
     61EA 8320 
0762 61EC 0996  56         srl   tmp2,9                ; Use control byte as counter
0763 61EE 0607  14         dec   tmp3                  ; Update length
0764 61F0 D174  28         movb  *tmp0+,tmp1           ; Byte to fill
0765 61F2 06A0  32         bl    @mcloop               ; Write data to VDP
     61F4 8320 
0766               *--------------------------------------------------------------
0767               *    Check if more data to decompress
0768               *--------------------------------------------------------------
0769 61F6 C1C7  18 rle2v3  mov   tmp3,tmp3             ; Length counter = 0 ?
0770 61F8 16E9  14         jne   rle2v0                ; Not yet, process data
0771               *--------------------------------------------------------------
0772               *    Exit
0773               *--------------------------------------------------------------
0774 61FA C2E0  34 rle2vz  mov   @waux1,r11
     61FC 833C 
0775 61FE 045B  20         b     *r11                  ; Return
0776 6200 D7F4     rledat  data  >d7f4                 ; MOVB *TMP0+,*R15
0777               
0778               
0779               
0780               
0781               *//////////////////////////////////////////////////////////////
0782               *                      VDP LOW LEVEL FUNCTIONS
0783               *//////////////////////////////////////////////////////////////
0784               
0785               ***************************************************************
0786               * VDWA / VDRA - Setup VDP write or read address
0787               ***************************************************************
0788               *  BL   @VDWA
0789               *
0790               *  TMP0 = VDP destination address for write
0791               *--------------------------------------------------------------
0792               *  BL   @VDRA
0793               *
0794               *  TMP0 = VDP source address for read
0795               ********|*****|*********************|**************************
0796 6202 0264  22 vdwa    ori   tmp0,>4000            ; Prepare VDP address for write
     6204 4000 
0797 6206 06C4  14 vdra    swpb  tmp0
0798 6208 D804  38         movb  tmp0,@vdpa
     620A 8C02 
0799 620C 06C4  14         swpb  tmp0
0800 620E D804  38         movb  tmp0,@vdpa            ; Set VDP address
     6210 8C02 
0801 6212 045B  20         b     *r11
0802               
0803               ***************************************************************
0804               * VPUTB - VDP put single byte
0805               ***************************************************************
0806               *  BL @VPUTB
0807               *  DATA P0,P1
0808               *--------------------------------------------------------------
0809               *  P0 = VDP target address
0810               *  P1 = Byte to write
0811               ********|*****|*********************|**************************
0812 6214 C13B  30 vputb   mov   *r11+,tmp0            ; Get VDP target address
0813 6216 C17B  30         mov   *r11+,tmp1
0814 6218 C18B  18 xvputb  mov   r11,tmp2              ; Save R11
0815 621A 06A0  32         bl    @vdwa                 ; Set VDP write address
     621C 6202 
0816               
0817 621E 06C5  14         swpb  tmp1                  ; Get byte to write
0818 6220 D7C5  30         movb  tmp1,*r15             ; Write byte
0819 6222 0456  20         b     *tmp2                 ; Exit
0820               
0821               
0822               ***************************************************************
0823               * VGETB - VDP get single byte
0824               ***************************************************************
0825               *  BL @VGETB
0826               *  DATA P0
0827               *--------------------------------------------------------------
0828               *  P0 = VDP source address
0829               ********|*****|*********************|**************************
0830 6224 C13B  30 vgetb   mov   *r11+,tmp0            ; Get VDP source address
0831 6226 C18B  18 xvgetb  mov   r11,tmp2              ; Save R11
0832 6228 06A0  32         bl    @vdra                 ; Set VDP read address
     622A 6206 
0833               
0834 622C D120  34         movb  @vdpr,tmp0            ; Read byte
     622E 8800 
0835               
0836 6230 0984  56         srl   tmp0,8                ; Right align
0837 6232 0456  20         b     *tmp2                 ; Exit
0838               
0839               ***************************************************************
0840               * VIDTAB - Dump videomode table
0841               ***************************************************************
0842               *  BL   @VIDTAB
0843               *  DATA P0
0844               *--------------------------------------------------------------
0845               *  P0 = Address of video mode table
0846               *--------------------------------------------------------------
0847               *  BL   @XIDTAB
0848               *
0849               *  TMP0 = Address of video mode table
0850               *--------------------------------------------------------------
0851               *  Remarks
0852               *  TMP1 = MSB is the VDP target register
0853               *         LSB is the value to write
0854               ********|*****|*********************|**************************
0855 6234 C13B  30 vidtab  mov   *r11+,tmp0            ; Get video mode table
0856 6236 C394  26 xidtab  mov   *tmp0,r14             ; Store copy of VDP#0 and #1 in RAM
0857               *--------------------------------------------------------------
0858               * Calculate PNT base address
0859               *--------------------------------------------------------------
0860 6238 C144  18         mov   tmp0,tmp1
0861 623A 05C5  14         inct  tmp1
0862 623C D155  26         movb  *tmp1,tmp1            ; Get value for VDP#2
0863 623E 0245  22         andi  tmp1,>ff00            ; Only keep MSB
     6240 FF00 
0864 6242 0A25  56         sla   tmp1,2                ; TMP1 *= 400
0865 6244 C805  38         mov   tmp1,@wbase           ; Store calculated base
     6246 8328 
0866               *--------------------------------------------------------------
0867               * Dump VDP shadow registers
0868               *--------------------------------------------------------------
0869 6248 0205  20         li    tmp1,>8000            ; Start with VDP register 0
     624A 8000 
0870 624C 0206  20         li    tmp2,8
     624E 0008 
0871 6250 D834  48 vidta1  movb  *tmp0+,@tmp1lb        ; Write value to VDP register
     6252 830B 
0872 6254 06C5  14         swpb  tmp1
0873 6256 D805  38         movb  tmp1,@vdpa
     6258 8C02 
0874 625A 06C5  14         swpb  tmp1
0875 625C D805  38         movb  tmp1,@vdpa
     625E 8C02 
0876 6260 0225  22         ai    tmp1,>0100
     6262 0100 
0877 6264 0606  14         dec   tmp2
0878 6266 16F4  14         jne   vidta1                ; Next register
0879 6268 C814  46         mov   *tmp0,@wcolmn         ; Store # of columns per row
     626A 833A 
0880 626C 045B  20         b     *r11
0881               
0882               
0883               ***************************************************************
0884               * PUTVR  - Put single VDP register
0885               ***************************************************************
0886               *  BL   @PUTVR
0887               *  DATA P0
0888               *--------------------------------------------------------------
0889               *  P0 = MSB is the VDP target register
0890               *       LSB is the value to write
0891               *--------------------------------------------------------------
0892               *  BL   @PUTVRX
0893               *
0894               *  TMP0 = MSB is the VDP target register
0895               *         LSB is the value to write
0896               ********|*****|*********************|**************************
0897 626E C13B  30 putvr   mov   *r11+,tmp0
0898 6270 0264  22 putvrx  ori   tmp0,>8000
     6272 8000 
0899 6274 06C4  14         swpb  tmp0
0900 6276 D804  38         movb  tmp0,@vdpa
     6278 8C02 
0901 627A 06C4  14         swpb  tmp0
0902 627C D804  38         movb  tmp0,@vdpa
     627E 8C02 
0903 6280 045B  20         b     *r11
0904               
0905               ***************************************************************
0906               * PUTV01  - Put VDP registers #0 and #1
0907               ***************************************************************
0908               *  BL   @PUTV01
0909               ********|*****|*********************|**************************
0910 6282 C20B  18 putv01  mov   r11,tmp4              ; Save R11
0911 6284 C10E  18         mov   r14,tmp0
0912 6286 0984  56         srl   tmp0,8
0913 6288 06A0  32         bl    @putvrx               ; Write VR#0
     628A 6270 
0914 628C 0204  20         li    tmp0,>0100
     628E 0100 
0915 6290 D820  54         movb  @r14lb,@tmp0lb
     6292 831D 
     6294 8309 
0916 6296 06A0  32         bl    @putvrx               ; Write VR#1
     6298 6270 
0917 629A 0458  20         b     *tmp4                 ; Exit
0918               
0919               ***************************************************************
0920               * SCROFF - Disable screen display
0921               ***************************************************************
0922               *  BL @SCROFF
0923               ********|*****|*********************|**************************
0924 629C 43A0  34 scroff  szc   @wbit9,r14            ; VDP#R1 bit 1=0 (Disable screen display)
     629E 603A 
0925 62A0 10F0  14         jmp   putv01
0926               
0927               ***************************************************************
0928               * SCRON - Disable screen display
0929               ***************************************************************
0930               *  BL @SCRON
0931               ********|*****|*********************|**************************
0932 62A2 E3A0  34 scron   soc   @wbit9,r14            ; VDP#R1 bit 1=1 (Enable screen display)
     62A4 603A 
0933 62A6 10ED  14         jmp   putv01
0934               
0935               ***************************************************************
0936               * INTOFF - Disable VDP interrupt
0937               ***************************************************************
0938               *  BL @INTOFF
0939               ********|*****|*********************|**************************
0940 62A8 43A0  34 intoff  szc   @wbit10,r14           ; VDP#R1 bit 2=0 (Disable VDP interrupt)
     62AA 603C 
0941 62AC 10EA  14         jmp   putv01
0942               
0943               ***************************************************************
0944               * INTON - Enable VDP interrupt
0945               ***************************************************************
0946               *  BL @INTON
0947               ********|*****|*********************|**************************
0948 62AE E3A0  34 inton   soc   @wbit10,r14           ; VDP#R1 bit 2=1 (Enable VDP interrupt)
     62B0 603C 
0949 62B2 10E7  14         jmp   putv01
0950               
0951               ***************************************************************
0952               * SMAG1X - Set sprite magnification 1x
0953               ***************************************************************
0954               *  BL @SMAG1X
0955               ********|*****|*********************|**************************
0956 62B4 43A0  34 smag1x  szc   @wbit14,r14           ; VDP#R1 bit 7=0 (Sprite magnification 1x)
     62B6 6044 
0957 62B8 10E4  14         jmp   putv01
0958               
0959               ***************************************************************
0960               * SMAG2X - Set sprite magnification 2x
0961               ***************************************************************
0962               *  BL @SMAG2X
0963               ********|*****|*********************|**************************
0964 62BA 43A0  34 smag2x  szc   @wbit14,r14           ; VDP#R1 bit 7=1 (Sprite magnification 2x)
     62BC 6044 
0965 62BE 10E1  14         jmp   putv01
0966               
0967               ***************************************************************
0968               * S8X8 - Set sprite size 8x8 bits
0969               ***************************************************************
0970               *  BL @S8X8
0971               ********|*****|*********************|**************************
0972 62C0 43A0  34 s8x8    szc   @wbit12,r14           ; VDP#R1 bit 6=0 (Sprite size 8x8)
     62C2 6040 
0973 62C4 10DE  14         jmp   putv01
0974               
0975               ***************************************************************
0976               * S16X16 - Set sprite size 16x16 bits
0977               ***************************************************************
0978               *  BL @S16X16
0979               ********|*****|*********************|**************************
0980 62C6 E3A0  34 s16x16  soc   @wbit12,r14           ; VDP#R1 bit 6=1 (Sprite size 16x16)
     62C8 6040 
0981 62CA 10DB  14         jmp   putv01
0982               
0983               ***************************************************************
0984               * YX2PNT - Get VDP PNT address for current YX cursor position
0985               ***************************************************************
0986               *  BL   @YX2PNT
0987               *--------------------------------------------------------------
0988               *  INPUT
0989               *  @WYX = Cursor YX position
0990               *--------------------------------------------------------------
0991               *  OUTPUT
0992               *  TMP0 = VDP address for entry in Pattern Name Table
0993               *--------------------------------------------------------------
0994               *  Register usage
0995               *  TMP0, R14, R15
0996               ********|*****|*********************|**************************
0997 62CC C10E  18 yx2pnt  mov   r14,tmp0              ; Save VDP#0 & VDP#1
0998 62CE C3A0  34         mov   @wyx,r14              ; Get YX
     62D0 832A 
0999 62D2 098E  56         srl   r14,8                 ; Right justify (remove X)
1000 62D4 3BA0  72         mpy   @wcolmn,r14           ; pos = Y * (columns per row)
     62D6 833A 
1001               *--------------------------------------------------------------
1002               * Do rest of calculation with R15 (16 bit part is there)
1003               * Re-use R14
1004               *--------------------------------------------------------------
1005 62D8 C3A0  34         mov   @wyx,r14              ; Get YX
     62DA 832A 
1006 62DC 024E  22         andi  r14,>00ff             ; Remove Y
     62DE 00FF 
1007 62E0 A3CE  18         a     r14,r15               ; pos = pos + X
1008 62E2 A3E0  34         a     @wbase,r15            ; pos = pos + (PNT base address)
     62E4 8328 
1009               *--------------------------------------------------------------
1010               * Clean up before exit
1011               *--------------------------------------------------------------
1012 62E6 C384  18         mov   tmp0,r14              ; Restore VDP#0 & VDP#1
1013 62E8 C10F  18         mov   r15,tmp0              ; Return pos in TMP0
1014 62EA 020F  20         li    r15,vdpw              ; VDP write address
     62EC 8C00 
1015 62EE 045B  20         b     *r11
1016               
1017               ***************************************************************
1018               * YX2PX - Get pixel position for cursor YX position
1019               ***************************************************************
1020               *  BL   @YX2PX
1021               *
1022               *  (CONFIG:0 = 1) = Skip sprite adjustment
1023               *--------------------------------------------------------------
1024               *  INPUT
1025               *  @WYX   = Cursor YX position
1026               *--------------------------------------------------------------
1027               *  OUTPUT
1028               *  TMP0HB = Y pixel position
1029               *  TMP0LB = X pixel position
1030               *--------------------------------------------------------------
1031               *  Remarks
1032               *  This subroutine does not support multicolor or text mode
1033               ********|*****|*********************|**************************
1034 62F0 C120  34 yx2px   mov   @wyx,tmp0
     62F2 832A 
1035 62F4 C18B  18 yx2pxx  mov   r11,tmp2              ; Save return address
1036 62F6 06C4  14         swpb  tmp0                  ; Y<->X
1037 62F8 04C5  14         clr   tmp1                  ; Clear before copy
1038 62FA D144  18         movb  tmp0,tmp1             ; Copy X to TMP1
1039 62FC 0A35  56         sla   tmp1,3                ; X=X*8
1040 62FE 0A34  56         sla   tmp0,3                ; Y=Y*8
1041 6300 D105  18         movb  tmp1,tmp0
1042 6302 06C4  14         swpb  tmp0                  ; X<->Y
1043 6304 2320  38 yx2pi1  coc   @wbit0,config         ; Skip sprite adjustment ?
     6306 6028 
1044 6308 1305  14         jeq   yx2pi3                ; Yes, exit
1045               *--------------------------------------------------------------
1046               * Adjust for Y sprite location
1047               * See VDP Programmers Guide, Section 9.2.1
1048               *--------------------------------------------------------------
1049 630A 7120  34 yx2pi2  sb    @bd1,tmp0             ; Adjust Y. Top of screen is at >FF
     630C 604B 
1050 630E 9120  34         cb    @bd208,tmp0           ; Y position = >D0 ?
     6310 6054 
1051 6312 13FB  14         jeq   yx2pi2                ; Yes, but that's not allowed, correct
1052 6314 0456  20 yx2pi3  b     *tmp2                 ; Exit
1053 6316 2000     bdig32  data  >2000
1054               
1055               
1056               ***************************************************************
1057               * PX2YX - Get YX tile position for specified YX pixel position
1058               ***************************************************************
1059               *  BL   @PX2YX
1060               *--------------------------------------------------------------
1061               *  INPUT
1062               *  TMP0   = Pixel YX position
1063               *
1064               *  (CONFIG:0 = 1) = Skip sprite adjustment
1065               *--------------------------------------------------------------
1066               *  OUTPUT
1067               *  TMP0HB = Y tile position
1068               *  TMP0LB = X tile position
1069               *  TMP1HB = Y pixel offset
1070               *  TMP1LB = X pixel offset
1071               *--------------------------------------------------------------
1072               *  Remarks
1073               *  This subroutine does not support multicolor or text mode
1074               ********|*****|*********************|**************************
1075 6318 2320  38 px2yx   coc   @wbit0,config         ; Skip sprite adjustment ?
     631A 6028 
1076 631C 1302  14         jeq   px2yx1
1077 631E 0224  22         ai    tmp0,>0100            ; Adjust Y. Top of screen is at >FF
     6320 0100 
1078 6322 C144  18 px2yx1  mov   tmp0,tmp1             ; Copy YX
1079 6324 C184  18         mov   tmp0,tmp2             ; Copy YX
1080               *--------------------------------------------------------------
1081               * Calculate Y tile position
1082               *--------------------------------------------------------------
1083 6326 09B4  56         srl   tmp0,11               ; Y: Move to TMP0LB & (Y = Y / 8)
1084               *--------------------------------------------------------------
1085               * Calculate Y pixel offset
1086               *--------------------------------------------------------------
1087 6328 C1C4  18         mov   tmp0,tmp3             ; Y: Copy Y tile to TMP3LB
1088 632A 0AB7  56         sla   tmp3,11               ; Y: Move to TMP3HB & (Y = Y * 8)
1089 632C 0507  16         neg   tmp3
1090 632E B1C5  18         ab    tmp1,tmp3             ; Y: offset = Y pixel old + (-Y) pixel new
1091               *--------------------------------------------------------------
1092               * Calculate X tile position
1093               *--------------------------------------------------------------
1094 6330 0245  22         andi  tmp1,>00ff            ; Clear TMP1HB
     6332 00FF 
1095 6334 0A55  56         sla   tmp1,5                ; X: Move to TMP1HB & (X = X / 8)
1096 6336 D105  18         movb  tmp1,tmp0             ; X: TMP0 <-- XY tile position
1097 6338 06C4  14         swpb  tmp0                  ; XY tile position <-> YX tile position
1098               *--------------------------------------------------------------
1099               * Calculate X pixel offset
1100               *--------------------------------------------------------------
1101 633A 0245  22         andi  tmp1,>ff00            ; X: Get rid of remaining junk in TMP1LB
     633C FF00 
1102 633E 0A35  56         sla   tmp1,3                ; X: (X = X * 8)
1103 6340 0505  16         neg   tmp1
1104 6342 06C6  14         swpb  tmp2                  ; YX <-> XY
1105 6344 B146  18         ab    tmp2,tmp1             ; offset X = X pixel old  + (-X) pixel new
1106 6346 06C5  14         swpb  tmp1                  ; X0 <-> 0X
1107 6348 D147  18         movb  tmp3,tmp1             ; 0X --> YX
1108 634A 045B  20         b     *r11                  ; Exit
1109               
1110               ***************************************************************
1111               * SCRDIM - Set (virtual) screen base and dimension
1112               ***************************************************************
1113               *  BL   @SCRDIM
1114               *--------------------------------------------------------------
1115               *  INPUT
1116               *  P0 = PNT base address
1117               *  P1 = Number of columns per row
1118               ********|*****|*********************|**************************
1119 634C C83B  50 scrdim  mov   *r11+,@wbase          ; VDP destination address
     634E 8328 
1120 6350 C83B  50         mov   *r11+,@wcolmn         ; Number of columns per row
     6352 833A 
1121 6354 045B  20         b     *r11                  ; Exit
1122               
1123               ***************************************************************
1124               * BITMAP - Set tiles for displaying bitmap picture
1125               ***************************************************************
1126               *  BL   @BITMAP
1127               ********|*****|*********************|**************************
1128 6356 C1CB  18 bitmap  mov   r11,tmp3              ; Save R11
1129 6358 C120  34         mov   @wbase,tmp0           ; Get PNT base address
     635A 8328 
1130 635C 06A0  32         bl    @vdwa                 ; Setup VDP write address
     635E 6202 
1131 6360 04C5  14         clr   tmp1
1132 6362 0206  20         li    tmp2,768              ; Write 768 bytes
     6364 0300 
1133               *--------------------------------------------------------------
1134               * Repeat 3 times: write bytes >00 .. >FF
1135               *--------------------------------------------------------------
1136 6366 D7C5  30 bitma1  movb  tmp1,*r15             ; Write byte
1137 6368 0225  22         ai    tmp1,>0100
     636A 0100 
1138 636C 0606  14         dec   tmp2
1139 636E 16FB  14         jne   bitma1
1140 6370 0457  20         b     *tmp3                 ; Exit
1141               
1142               *//////////////////////////////////////////////////////////////
1143               *                 VDP F18A LOW-LEVEL FUNCTIONS
1144               *//////////////////////////////////////////////////////////////
1145               
1146                       copy  "sp2f18a.a99"
**** **** ****     > sp2f18a.a99
0001               * FILE......: sp2f18a.a99
0002               * Purpose...: F18A Support library
0003               
0004               *//////////////////////////////////////////////////////////////
0005               *                 VDP F18A LOW-LEVEL FUNCTIONS
0006               *//////////////////////////////////////////////////////////////
0007               
0008               ***************************************************************
0009               * F18UNL - Unlock F18A VDP
0010               ***************************************************************
0011               *  BL   @F18UNL
0012               ********|*****|*********************|**************************
0013 6372 C20B  18 f18unl  mov   r11,tmp4              ; Save R11
0014 6374 06A0  32         bl    @putvr                ; Write once
     6376 626E 
0015 6378 391C             data  >391c                 ; VR1/57, value 00011100
0016 637A 06A0  32         bl    @putvr                ; Write twice, unlock F18A
     637C 626E 
0017 637E 391C             data  >391c
0018 6380 06A0  32         bl    @putvr                ; Write sane value
     6382 626E 
0019 6384 01E0             data  >01e0                 ; VR1, value 11100000
0020 6386 0458  20         b     *tmp4                 ; Exit
0021               
0022               
0023               ***************************************************************
0024               * F18LCK - Lock F18A VDP
0025               ***************************************************************
0026               *  BL   @F18LCK
0027               ********|*****|*********************|**************************
0028 6388 C20B  18 f18lck  mov   r11,tmp4              ; Save R11
0029 638A 06A0  32         bl    @putvr                ; VR1/57, value 00011100
     638C 626E 
0030 638E 391C             data  >391c
0031 6390 0458  20         b     *tmp4                 ; Exit
0032               
0033               
0034               ***************************************************************
0035               * F18CHK - Check if F18A VDP present
0036               ***************************************************************
0037               *  BL   @F18CHK
0038               *--------------------------------------------------------------
0039               *  REMARKS
0040               *  VDP memory >3f00->3f05 still has part of GPU code upon exit.
0041               ********|*****|*********************|**************************
0042 6392 C20B  18 f18chk  mov   r11,tmp4              ; Save R11
0043 6394 06A0  32         bl    @cpym2v
     6396 6120 
0044 6398 3F00             data  >3f00,f18gpu,6        ; Copy F18A GPU code to VRAM
     639A 63D6 
     639C 0006 
0045 639E 06A0  32         bl    @putvr
     63A0 626E 
0046 63A2 363F             data  >363f                 ; Load MSB of GPU PC (>3f) into VR54 (>36)
0047 63A4 06A0  32         bl    @putvr
     63A6 626E 
0048 63A8 3700             data  >3700                 ; Load LSB of GPU PC (>00) into VR55 (>37)
0049                                                   ; GPU code should run now
0050               ***************************************************************
0051               * VDP @>3f00 == 0 ? F18A present : F18a not present
0052               ***************************************************************
0053 63AA 0204  20         li    tmp0,>3f00
     63AC 3F00 
0054 63AE 06A0  32         bl    @vdra                 ; Set VDP read address to >3f00
     63B0 6206 
0055 63B2 D120  34         movb  @vdpr,tmp0            ; Read MSB byte
     63B4 8800 
0056 63B6 0984  56         srl   tmp0,8
0057 63B8 D120  34         movb  @vdpr,tmp0            ; Read LSB byte
     63BA 8800 
0058 63BC C104  18         mov   tmp0,tmp0             ; For comparing with 0
0059 63BE 1303  14         jeq   f18yes
0060 63C0 024C  22 f18no   andi  config,>bfff          ; CONFIG Register bit 1=0
     63C2 BFFF 
0061 63C4 1002  14         jmp   f18exi
0062 63C6 026C  22 f18yes  ori   config,>4000          ; CONFIG Register bit 1=1
     63C8 4000 
0063 63CA 06A0  32 f18exi  bl    @filv                 ; Clear VDP mem >3f00->3f07
     63CC 60AE 
0064 63CE 3F00             data  >3f00,>00,6
     63D0 0000 
     63D2 0006 
0065 63D4 0458  20         b     *tmp4                 ; Exit
0066               ***************************************************************
0067               * GPU code
0068               ********|*****|*********************|**************************
0069 63D6 04E0     f18gpu  data  >04e0                 ; 3f00 \ 04e0  clr @>3f00
0070 63D8 3F00             data  >3f00                 ; 3f02 / 3f00
0071 63DA 0340             data  >0340                 ; 3f04   0340  idle
0072               
0073               
0074               
0075               ***************************************************************
0076               * F18FWV - Get F18A Firmware Version
0077               ***************************************************************
0078               *  BL   @F18FWV
0079               *--------------------------------------------------------------
0080               *  REMARKS
0081               *  Successfully tested with F18A v1.8, note that this does not
0082               *  work with F18 v1.3 but you shouldn't be using such old F18A
0083               *  firmware to begin with.
0084               *--------------------------------------------------------------
0085               *  TMP0 High nibble = major version
0086               *  TMP0 Low nibble  = minor version
0087               *
0088               *  Example: >0018     F18a Firmware v1.8
0089               ********|*****|*********************|**************************
0090 63DC C20B  18 f18fwv  mov   r11,tmp4              ; Save R11
0091 63DE 2320  38         coc   @wbit1,config         ; CONFIG bit 1 set ?
     63E0 602A 
0092 63E2 1609  14         jne   f18fw1
0093               ***************************************************************
0094               * Read F18A major/minor version
0095               ***************************************************************
0096 63E4 C120  34         mov   @vdps,tmp0            ; Clear VDP status register
     63E6 8802 
0097 63E8 06A0  32         bl    @putvr                ; Write to VR#15 for setting F18A status
     63EA 626E 
0098 63EC 0F0E             data  >0f0e                 ; register to read (0e=VR#14)
0099 63EE 04C4  14         clr   tmp0
0100 63F0 D120  34         movb  @vdps,tmp0
     63F2 8802 
0101 63F4 0984  56         srl   tmp0,8
0102 63F6 0458  20 f18fw1  b     *tmp4                 ; Exit
0103               
**** **** ****     > runlib.a99
1147               
1148               
1149               *//////////////////////////////////////////////////////////////
1150               *                      VDP TILE FUNCTIONS
1151               *//////////////////////////////////////////////////////////////
1152               
1153               ***************************************************************
1154               * LDFNT - Load TI-99/4A font from GROM into VDP
1155               ***************************************************************
1156               *  BL   @LDFNT
1157               *  DATA P0,P1
1158               *--------------------------------------------------------------
1159               *  P0 = VDP Target address
1160               *  P1 = Font options
1161               ********|*****|*********************|**************************
1162 63F8 C20B  18 ldfnt   mov   r11,tmp4              ; Save R11
1163 63FA 05CB  14         inct  r11                   ; Get 2nd parameter (font options)
1164 63FC C11B  26         mov   *r11,tmp0             ; Get parameter value
1165 63FE 024C  22         andi  config,>7fff          ; CONFIG register bit 0=0
     6400 7FFF 
1166 6402 2120  38         coc   @wbit0,tmp0
     6404 6028 
1167 6406 1604  14         jne   ldfnt1
1168 6408 026C  22         ori   config,>8000          ; CONFIG register bit 0=1
     640A 8000 
1169 640C 0244  22         andi  tmp0,>7fff            ; Parameter value bit 0=0
     640E 7FFF 
1170 6410 C124  34 ldfnt1  mov   @tmp006(tmp0),tmp0    ; Load GROM index address ...
     6412 6470 
1171 6414 0205  20         li    tmp1,tmp3hb           ; ... into register TMP3
     6416 830E 
1172 6418 0206  20         li    tmp2,2
     641A 0002 
1173 641C 06A0  32         bl    @xpyg2m               ; Get font table address
     641E 616E 
1174               *--------------------------------------------------------------
1175               
1176               *--------------------------------------------------------------
1177 6420 D807  38         movb  tmp3,@grmwa
     6422 9C02 
1178 6424 06C7  14         swpb  tmp3
1179 6426 D807  38         movb  tmp3,@grmwa           ; Setup GROM address for reading
     6428 9C02 
1180 642A C118  26         mov   *tmp4,tmp0            ; Get 1st parameter (VDP destination)
1181 642C 06A0  32         bl    @vdwa                 ; Setup VDP destination address
     642E 6202 
1182 6430 05C8  14         inct  tmp4                  ; R11=R11+2
1183 6432 C158  26         mov   *tmp4,tmp1            ; Get font options into TMP1
1184 6434 0245  22         andi  tmp1,>7fff            ; Parameter value bit 0=0
     6436 7FFF 
1185 6438 C1A5  34         mov   @tmp006+2(tmp1),tmp2  ; Get number of patterns to copy
     643A 6472 
1186 643C C165  34         mov   @tmp006+4(tmp1),tmp1  ; 7 or 8 byte pattern ?
     643E 6474 
1187               *--------------------------------------------------------------
1188               * Copy from GROM to VRAM
1189               *--------------------------------------------------------------
1190 6440 0B15  56 ldfnt2  src   tmp1,1                ; Carry set ?
1191 6442 1812  14         joc   ldfnt4                ; Yes, go insert a >00
1192 6444 D120  34         movb  @grmrd,tmp0
     6446 9800 
1193               *--------------------------------------------------------------
1194               *   Make font fat
1195               *--------------------------------------------------------------
1196 6448 2320  38         coc   @wbit0,config         ; Fat flag set ?
     644A 6028 
1197 644C 1603  14         jne   ldfnt3                ; No, so skip
1198 644E D3C4  18         movb  tmp0,tmp6
1199 6450 091F  56         srl   tmp6,1
1200 6452 E10F  18         soc   tmp6,tmp0
1201               *-------------------------------------------------------------
1202               *   Dump byte to VDP and do housekeeping
1203               *--------------------------------------------------------------
1204 6454 D804  38 ldfnt3  movb  tmp0,@vdpw            ; Dump byte to VRAM
     6456 8C00 
1205 6458 0606  14         dec   tmp2
1206 645A 16F2  14         jne   ldfnt2
1207 645C 05C8  14         inct  tmp4                  ; R11=R11+2
1208 645E 020F  20         li    r15,vdpw              ; Set VDP write address
     6460 8C00 
1209 6462 024C  22         andi  config,>7fff          ; CONFIG register bit 0=0
     6464 7FFF 
1210 6466 0458  20         b     *tmp4                 ; Exit
1211 6468 D820  54 ldfnt4  movb  @bd0,@vdpw            ; Insert byte >00 into VRAM
     646A 604A 
     646C 8C00 
1212 646E 10E8  14         jmp   ldfnt2
1213 6470 004C     tmp006  data  >004c,64*8,>0000      ; Pointer to TI title screen font
     6472 0200 
     6474 0000 
1214 6476 004E             data  >004e,64*7,>0101      ; Pointer to upper case font
     6478 01C0 
     647A 0101 
1215 647C 004E             data  >004e,96*7,>0101      ; Pointer to upper & lower case font
     647E 02A0 
     6480 0101 
1216 6482 0050             data  >0050,32*7,>0101      ; Pointer to lower case font
     6484 00E0 
     6486 0101 
1217               
1218               
1219               ***************************************************************
1220               * Put length-byte prefixed string at current YX
1221               ***************************************************************
1222               *  BL   @PUTSTR
1223               *  DATA P0
1224               *
1225               *  P0 = Pointer to string
1226               *--------------------------------------------------------------
1227               *  REMARKS
1228               *  First byte of string must contain length
1229               ********|*****|*********************|**************************
1230 6488 C17B  30 putstr  mov   *r11+,tmp1
1231 648A D1B5  28 xutst0  movb  *tmp1+,tmp2           ; Get length byte
1232 648C C1CB  18 xutstr  mov   r11,tmp3
1233 648E 06A0  32         bl    @yx2pnt               ; Get VDP destination address
     6490 62CC 
1234 6492 C2C7  18         mov   tmp3,r11
1235 6494 0986  56         srl   tmp2,8                ; Right justify length byte
1236 6496 0460  28         b     @xpym2v               ; Display string
     6498 6126 
1237               
1238               
1239               ***************************************************************
1240               * Put length-byte prefixed string at YX
1241               ***************************************************************
1242               *  BL   @PUTAT
1243               *  DATA P0,P1
1244               *
1245               *  P0 = YX position
1246               *  P1 = Pointer to string
1247               *--------------------------------------------------------------
1248               *  REMARKS
1249               *  First byte of string must contain length
1250               ********|*****|*********************|**************************
1251 649A C83B  50 putat   mov   *r11+,@wyx            ; Set YX position
     649C 832A 
1252 649E 0460  28         b     @putstr
     64A0 6488 
1253               
1254               
1255               ***************************************************************
1256               * Repeat characters horizontally at YX
1257               ***************************************************************
1258               *  BL    @HCHAR
1259               *  DATA  P0,P1
1260               *  ...
1261               *  DATA  EOL                        ; End-of-list
1262               *--------------------------------------------------------------
1263               *  P0HB = Y position
1264               *  P0LB = X position
1265               *  P1HB = Byte to write
1266               *  P1LB = Number of times to repeat
1267               ********|*****|*********************|**************************
1268 64A2 C83B  50 hchar   mov   *r11+,@wyx            ; Set YX position
     64A4 832A 
1269 64A6 D17B  28         movb  *r11+,tmp1
1270 64A8 0985  56         srl   tmp1,8                ; Byte to write
1271 64AA D1BB  28         movb  *r11+,tmp2
1272 64AC 0986  56         srl   tmp2,8                ; Repeat count
1273 64AE C1CB  18         mov   r11,tmp3
1274 64B0 06A0  32         bl    @yx2pnt               ; Get VDP address into TMP0
     64B2 62CC 
1275               *--------------------------------------------------------------
1276               *    Draw line
1277               *--------------------------------------------------------------
1278 64B4 020B  20         li    r11,hchar1
     64B6 64BC 
1279 64B8 0460  28         b     @xfilv                ; Draw
     64BA 60B4 
1280               *--------------------------------------------------------------
1281               *    Do housekeeping
1282               *--------------------------------------------------------------
1283 64BC 8817  46 hchar1  c     *tmp3,@whffff         ; End-Of-List marker found ?
     64BE 6048 
1284 64C0 1302  14         jeq   hchar2                ; Yes, exit
1285 64C2 C2C7  18         mov   tmp3,r11
1286 64C4 10EE  14         jmp   hchar                 ; Next one
1287 64C6 05C7  14 hchar2  inct  tmp3
1288 64C8 0457  20         b     *tmp3                 ; Exit
1289               
1290               
1291               ***************************************************************
1292               * Repeat characters vertically at YX
1293               ***************************************************************
1294               *  BL    @VCHAR
1295               *  DATA  P0,P1
1296               *  ...
1297               *  DATA  EOL                        ; End-of-list
1298               *--------------------------------------------------------------
1299               *  P0HB = Y position
1300               *  P0LB = X position
1301               *  P1HB = Byte to write
1302               *  P1LB = Number of times to repeat
1303               ********|*****|*********************|**************************
1304 64CA C83B  50 vchar   mov   *r11+,@wyx            ; Set YX position
     64CC 832A 
1305 64CE C1CB  18         mov   r11,tmp3              ; Save R11 in TMP3
1306 64D0 C220  34 vchar1  mov   @wcolmn,tmp4          ; Get columns per row
     64D2 833A 
1307 64D4 06A0  32         bl    @yx2pnt               ; Get VDP address into TMP0
     64D6 62CC 
1308 64D8 D177  28         movb  *tmp3+,tmp1           ; Byte to write
1309 64DA D1B7  28         movb  *tmp3+,tmp2
1310 64DC 0986  56         srl   tmp2,8                ; Repeat count
1311               *--------------------------------------------------------------
1312               *    Setup VDP write address
1313               *--------------------------------------------------------------
1314 64DE 06A0  32 vchar2  bl    @vdwa                 ; Setup VDP write address
     64E0 6202 
1315               *--------------------------------------------------------------
1316               *    Dump tile to VDP and do housekeeping
1317               *--------------------------------------------------------------
1318 64E2 D7C5  30         movb  tmp1,*r15             ; Dump tile to VDP
1319 64E4 A108  18         a     tmp4,tmp0             ; Next row
1320 64E6 0606  14         dec   tmp2
1321 64E8 16FA  14         jne   vchar2
1322 64EA 8817  46         c     *tmp3,@whffff         ; End-Of-List marker found ?
     64EC 6048 
1323 64EE 1303  14         jeq   vchar3                ; Yes, exit
1324 64F0 C837  50         mov   *tmp3+,@wyx           ; Save YX position
     64F2 832A 
1325 64F4 10ED  14         jmp   vchar1                ; Next one
1326 64F6 05C7  14 vchar3  inct  tmp3
1327 64F8 0457  20         b     *tmp3                 ; Exit
1328               
1329               ***************************************************************
1330               * Repeat characters vertically at YX
1331               ***************************************************************
1332               * TMP0 = YX position
1333               * TMP1 = Byte to write
1334               * TMP2 = Repeat count
1335               ***************************************************************
1336 64FA C20B  18 xvchar  mov   r11,tmp4              ; Save return address
1337 64FC C804  38         mov   tmp0,@wyx             ; Set cursor position
     64FE 832A 
1338 6500 06C5  14         swpb  tmp1                  ; Byte to write into MSB
1339 6502 C1E0  34         mov   @wcolmn,tmp3          ; Get columns per row
     6504 833A 
1340 6506 06A0  32         bl    @yx2pnt               ; Get VDP address into TMP0
     6508 62CC 
1341               *--------------------------------------------------------------
1342               *    Setup VDP write address
1343               *--------------------------------------------------------------
1344 650A 06A0  32 xvcha1  bl    @vdwa                 ; Setup VDP write address
     650C 6202 
1345               *--------------------------------------------------------------
1346               *    Dump tile to VDP and do housekeeping
1347               *--------------------------------------------------------------
1348 650E D7C5  30         movb  tmp1,*r15             ; Dump tile to VDP
1349 6510 A120  34         a     @wcolmn,tmp0          ; Next row
     6512 833A 
1350 6514 0606  14         dec   tmp2
1351 6516 16F9  14         jne   xvcha1
1352 6518 0458  20         b     *tmp4                 ; Exit
1353               
1354               ***************************************************************
1355               * FILBOX - Fill box with character
1356               ***************************************************************
1357               *  BL   @FILBOX
1358               *  DATA P0,P1,P2
1359               *  ...
1360               *  DATA EOL
1361               *--------------------------------------------------------------
1362               *  P0HB = Upper left corner Y
1363               *  P0LB = Upper left corner X
1364               *  P1HB = Height
1365               *  P1LB = Width
1366               *  P2HB = >00
1367               *  P2LB = Character to fill
1368               ********|*****|*********************|**************************
1369 651A C83B  50 filbox  mov   *r11+,@wyx            ; Upper left corner
     651C 832A 
1370 651E D1FB  28         movb  *r11+,tmp3            ; Height in TMP3
1371 6520 D1BB  28         movb  *r11+,tmp2            ; Width in TMP2
1372 6522 C17B  30         mov   *r11+,tmp1            ; Byte to fill
1373 6524 C20B  18         mov   r11,tmp4              ; Save R11
1374 6526 0986  56         srl   tmp2,8                ; Right-align width
1375 6528 0987  56         srl   tmp3,8                ; Right-align height
1376               *--------------------------------------------------------------
1377               *  Do single row
1378               *--------------------------------------------------------------
1379 652A 06A0  32 filbo1  bl    @yx2pnt               ; Get VDP address into TMP0
     652C 62CC 
1380 652E 020B  20         li    r11,filbo2            ; New return address
     6530 6536 
1381 6532 0460  28         b     @xfilv                ; Fill VRAM with byte
     6534 60B4 
1382               *--------------------------------------------------------------
1383               *  Recover width & character
1384               *--------------------------------------------------------------
1385 6536 C108  18 filbo2  mov   tmp4,tmp0
1386 6538 0224  22         ai    tmp0,-3               ; R11 - 3
     653A FFFD 
1387 653C D1B4  28         movb  *tmp0+,tmp2           ; Get Width/Height
1388 653E 0986  56         srl   tmp2,8                ; Right align
1389 6540 C154  26         mov   *tmp0,tmp1            ; Get character to fill
1390               *--------------------------------------------------------------
1391               *  Housekeeping
1392               *--------------------------------------------------------------
1393 6542 A820  54         a     @wh100,@by            ; Y=Y+1
     6544 6036 
     6546 832A 
1394 6548 0607  14         dec   tmp3
1395 654A 15EF  14         jgt   filbo1                ; Process next row
1396 654C 8818  46         c     *tmp4,@whffff         ; End-Of-List marker found ?
     654E 6048 
1397 6550 1302  14         jeq   filbo3                ; Yes, exit
1398 6552 C2C8  18         mov   tmp4,r11
1399 6554 10E2  14         jmp   filbox                ; Next one
1400 6556 05C8  14 filbo3  inct  tmp4
1401 6558 0458  20         b     *tmp4                 ; Exit
1402               
1403               
1404               ***************************************************************
1405               * PUTBOX - Put tiles in box
1406               ***************************************************************
1407               *  BL   @PUTBOX
1408               *  DATA P0,P1,P2,P3
1409               *  ...
1410               *  DATA EOL
1411               *--------------------------------------------------------------
1412               *  P0HB = Upper left corner Y
1413               *  P0LB = Upper left corner X
1414               *  P1HB = Box height
1415               *  P1LB = Box width
1416               *  P2   = Pointer to length-byte prefixed string
1417               *  P3HB = Repeat box A-times vertically
1418               *  P3LB = Repeat box B-times horizontally
1419               *--------------------------------------------------------------
1420               *  Register usage
1421               *  ; TMP0   = work copy of YX cursor position
1422               *  ; TMP1HB = Width  of box + X
1423               *  ; TMP2HB = Height of box + Y
1424               *  ; TMP3   = Pointer to string
1425               *  ; TMP4   = Counter for string
1426               *  ; @WAUX1 = Box AB repeat count
1427               *  ; @WAUX2 = Copy of R11
1428               *  ; @WAUX3 = YX position for next diagonal box
1429               *--------------------------------------------------------------
1430               *  ; Only byte operations on TMP1HB & TMP2HB.
1431               *  ; LO bytes of TMP1 and TMP2 reserved for future use.
1432               ********|*****|*********************|**************************
1433 655A C13B  30 putbox  mov   *r11+,tmp0            ; P0 - Upper left corner YX
1434 655C C15B  26         mov   *r11,tmp1             ; P1 - Height/Width in TMP1
1435 655E C1BB  30         mov   *r11+,tmp2            ; P1 - Height/Width in TMP2
1436 6560 C1FB  30         mov   *r11+,tmp3            ; P2 - Pointer to string
1437 6562 C83B  50         mov   *r11+,@waux1          ; P3 - Box repeat count AB
     6564 833C 
1438 6566 C80B  38         mov   r11,@waux2            ; Save R11
     6568 833E 
1439               *--------------------------------------------------------------
1440               *  Calculate some positions
1441               *--------------------------------------------------------------
1442 656A B184  18 putbo0  ab    tmp0,tmp2             ; TMP2HB = height + Y
1443 656C 06C4  14         swpb  tmp0
1444 656E 06C5  14         swpb  tmp1
1445 6570 B144  18         ab    tmp0,tmp1             ; TMP1HB = width  + X
1446 6572 06C4  14         swpb  tmp0
1447 6574 0A1C  56         sla   config,1              ; \ clear config bit 0
1448 6576 091C  56         srl   config,1              ; / is only 4 bytes
1449 6578 C804  38         mov   tmp0,@waux3           ; Set additional work copy of YX cursor
     657A 8340 
1450               *--------------------------------------------------------------
1451               *  Setup VDP write address
1452               *--------------------------------------------------------------
1453 657C C804  38 putbo1  mov   tmp0,@wyx             ; Set YX cursor
     657E 832A 
1454 6580 06A0  32         bl    @yx2pnt               ; Calculate VDP address from @WYX
     6582 62CC 
1455 6584 06A0  32         bl    @vdwa                 ; Set VDP write address from TMP0
     6586 6202 
1456 6588 C120  34         mov   @wyx,tmp0
     658A 832A 
1457               *--------------------------------------------------------------
1458               *  Prepare string for processing
1459               *--------------------------------------------------------------
1460 658C 2320  38         coc   @wbit0,config         ; state flag set ?
     658E 6028 
1461 6590 1302  14         jeq   putbo2                ; Yes, skip length byte
1462 6592 D237  28         movb  *tmp3+,tmp4           ; Get length byte ...
1463 6594 0988  56         srl   tmp4,8                ; ... and right justify
1464               *--------------------------------------------------------------
1465               *  Write line of tiles in box
1466               *--------------------------------------------------------------
1467 6596 D7F7  40 putbo2  movb  *tmp3+,*r15           ; Write to VDP
1468 6598 0608  14         dec   tmp4
1469 659A 1310  14         jeq   putbo3                ; End of string. Repeat box ?
1470               *--------------------------------------------------------------
1471               *    Adjust cursor
1472               *--------------------------------------------------------------
1473 659C 0584  14         inc   tmp0                  ; X=X+1
1474 659E 06C4  14         swpb  tmp0
1475 65A0 9144  18         cb    tmp0,tmp1             ; Right boundary reached ?
1476 65A2 06C4  14         swpb  tmp0
1477 65A4 11F8  14         jlt   putbo2                ; Not yet, continue
1478 65A6 0224  22         ai    tmp0,>0100            ; Y=Y+1
     65A8 0100 
1479 65AA D804  38         movb  tmp0,@wyx             ; Update Y cursor
     65AC 832A 
1480 65AE 9184  18         cb    tmp0,tmp2             ; Bottom boundary reached ?
1481 65B0 1305  14         jeq   putbo3                ; Yes, exit
1482               *--------------------------------------------------------------
1483               *  Recover starting column
1484               *--------------------------------------------------------------
1485 65B2 C120  34         mov   @wyx,tmp0             ; ... from YX cursor
     65B4 832A 
1486 65B6 026C  22         ori   config,>8000          ; CONFIG register bit 0=1
     65B8 8000 
1487 65BA 10E0  14         jmp   putbo1                ; Draw next line
1488               *--------------------------------------------------------------
1489               *  Handling repeating of box
1490               *--------------------------------------------------------------
1491 65BC C120  34 putbo3  mov   @waux1,tmp0           ; Repeat box ?
     65BE 833C 
1492 65C0 1328  14         jeq   putbo9                ; No, move on to next list entry
1493               *--------------------------------------------------------------
1494               *     Repeat horizontally
1495               *--------------------------------------------------------------
1496 65C2 06C4  14         swpb  tmp0                  ; BA
1497 65C4 D104  18         movb  tmp0,tmp0             ; B = 0 ?
1498 65C6 130D  14         jeq   putbo4                ; Yes, repeat vertically
1499 65C8 06C4  14         swpb  tmp0                  ; AB
1500 65CA 0604  14         dec   tmp0                  ; B = B - 1
1501 65CC C804  38         mov   tmp0,@waux1           ; Update AB repeat count
     65CE 833C 
1502 65D0 D805  38         movb  tmp1,@waux3+1         ; New X position
     65D2 8341 
1503 65D4 C120  34         mov   @waux3,tmp0           ; Get new YX position
     65D6 8340 
1504 65D8 C1E0  34         mov   @waux2,tmp3
     65DA 833E 
1505 65DC 0227  22         ai    tmp3,-6               ; Back to P1
     65DE FFFA 
1506 65E0 1014  14         jmp   putbo8
1507               *--------------------------------------------------------------
1508               *     Repeat vertically
1509               *--------------------------------------------------------------
1510 65E2 06C4  14 putbo4  swpb  tmp0                  ; AB
1511 65E4 D104  18         movb  tmp0,tmp0             ; A = 0 ?
1512 65E6 13EA  14         jeq   putbo3                ; Yes, check next entry in list
1513 65E8 0224  22         ai    tmp0,->0100           ; A = A - 1
     65EA FF00 
1514 65EC C804  38         mov   tmp0,@waux1           ; Update AB repeat count
     65EE 833C 
1515 65F0 C1E0  34         mov   @waux2,tmp3           ; \
     65F2 833E 
1516 65F4 0607  14         dec   tmp3                  ; / Back to P3LB
1517 65F6 D817  46         movb  *tmp3,@waux1+1        ; Update B repeat count
     65F8 833D 
1518 65FA D106  18         movb  tmp2,tmp0             ; New Y position
1519 65FC 06C4  14         swpb  tmp0
1520 65FE 0227  22         ai    tmp3,-6               ; Back to P0LB
     6600 FFFA 
1521 6602 D137  28         movb  *tmp3+,tmp0
1522 6604 06C4  14         swpb  tmp0
1523 6606 C804  38         mov   tmp0,@waux3           ; Set new YX position
     6608 8340 
1524               *--------------------------------------------------------------
1525               *      Get Height, Width and reset string pointer
1526               *--------------------------------------------------------------
1527 660A C157  26 putbo8  mov   *tmp3,tmp1            ; Get P1 into TMP1
1528 660C C1B7  30         mov   *tmp3+,tmp2           ; Get P1 into TMP2
1529 660E C1D7  26         mov   *tmp3,tmp3            ; Get P2 into TMP3
1530 6610 10AC  14         jmp   putbo0                ; Next box
1531               *--------------------------------------------------------------
1532               *  Next entry in list
1533               *--------------------------------------------------------------
1534 6612 C2E0  34 putbo9  mov   @waux2,r11            ; Restore R11
     6614 833E 
1535 6616 881B  46         c     *r11,@whffff          ; End-Of-List marker found ?
     6618 6048 
1536 661A 1301  14         jeq   putboa                ; Yes, exit
1537 661C 109E  14         jmp   putbox                ; Next one
1538 661E 0A2C  56 putboa  sla   config,2              ; \ clear config bits 0 & 1
1539 6620 092C  56         srl   config,2              ; / is only 4 bytes
1540 6622 045B  20         b     *r11                  ; Exit
1541               
1542               
1543               ***************************************************************
1544               * MKNUM - Convert unsigned number to string
1545               ***************************************************************
1546               *  BL   @MKNUM
1547               *  DATA P0,P1,P2
1548               *
1549               *  P0   = Pointer to 16 bit unsigned number
1550               *  P1   = Pointer to 5 byte string buffer
1551               *  P2HB = Offset for ASCII digit
1552               *  P2LB = Character for replacing leading 0's
1553               *
1554               *  (CONFIG:0 = 1) = Display number at cursor YX
1555               ********|*****|*********************|**************************
1556 6624 0207  20 mknum   li    tmp3,5                ; Digit counter
     6626 0005 
1557 6628 C17B  30         mov   *r11+,tmp1            ; \ Get 16 bit unsigned number
1558 662A C155  26         mov   *tmp1,tmp1            ; /
1559 662C C23B  30         mov   *r11+,tmp4            ; Pointer to string buffer
1560 662E 0228  22         ai    tmp4,4                ; Get end of buffer
     6630 0004 
1561 6632 0206  20         li    tmp2,10               ; Divide by 10 to isolate last digit
     6634 000A 
1562               *--------------------------------------------------------------
1563               *  Do string conversion
1564               *--------------------------------------------------------------
1565 6636 04C4  14 mknum1  clr   tmp0                  ; Clear the high word of the dividend
1566 6638 3D06  128         div   tmp2,tmp0             ; (TMP0:TMP1) / 10 (TMP2)
1567 663A 06C5  14         swpb  tmp1                  ; Move to high-byte for writing to buffer
1568 663C B15B  26         ab    *r11,tmp1             ; Add offset for ASCII digit
1569 663E D605  30         movb  tmp1,*tmp4            ; Write remainder to string buffer
1570 6640 C144  18         mov   tmp0,tmp1             ; Move integer result into R4 for the next digit
1571 6642 0608  14         dec   tmp4                  ; Adjust string pointer for next digit
1572 6644 0607  14         dec   tmp3                  ; Decrease counter
1573 6646 16F7  14         jne   mknum1                ; Do next digit
1574               *--------------------------------------------------------------
1575               *  Replace leading 0's with fill character
1576               *--------------------------------------------------------------
1577 6648 0207  20         li    tmp3,4                ; Check first 4 digits
     664A 0004 
1578 664C 0588  14         inc   tmp4                  ; Too far, back to buffer start
1579 664E C11B  26         mov   *r11,tmp0
1580 6650 0A84  56         sla   tmp0,8                ; Only keep fill character in HB
1581 6652 96D8  38 mknum2  cb    *tmp4,*r11            ; Digit = 0 ?
1582 6654 1305  14         jeq   mknum4                ; Yes, replace with fill character
1583 6656 05CB  14 mknum3  inct  r11
1584 6658 2320  38         coc   @wbit0,config         ; Check if 'display' bit is set
     665A 6028 
1585 665C 1305  14         jeq   mknum5                ; Yes, so show at current YX position
1586 665E 045B  20         b     *r11                  ; Exit
1587 6660 DE04  32 mknum4  movb  tmp0,*tmp4+           ; Replace leading 0 with fill character
1588 6662 0607  14         dec   tmp3                  ; 4th digit processed ?
1589 6664 13F8  14         jeq   mknum3                ; Yes, exit
1590 6666 10F5  14         jmp   mknum2                ; No, next one
1591               *--------------------------------------------------------------
1592               *  Display integer on screen at current YX position
1593               *--------------------------------------------------------------
1594 6668 024C  22 mknum5  andi  config,>7fff          ; Reset bit 0
     666A 7FFF 
1595 666C C10B  18         mov   r11,tmp0
1596 666E 0224  22         ai    tmp0,-4
     6670 FFFC 
1597 6672 C154  26         mov   *tmp0,tmp1            ; Get buffer address
1598 6674 0206  20         li    tmp2,>0500            ; String length = 5
     6676 0500 
1599 6678 0460  28         b     @xutstr               ; Display string
     667A 648C 
1600               
1601               
1602               ***************************************************************
1603               * PUTNUM - Put unsigned number on screen
1604               ***************************************************************
1605               *  BL   @PUTNUM
1606               *  DATA P0,P1,P2,P3
1607               *--------------------------------------------------------------
1608               *  P0   = YX position
1609               *  P1   = Pointer to 16 bit unsigned number
1610               *  P2   = Pointer to 5 byte string buffer
1611               *  P3HB = Offset for ASCII digit
1612               *  P3LB = Character for replacing leading 0's
1613               ********|*****|*********************|**************************
1614 667C C83B  50 putnum  mov   *r11+,@wyx            ; Set cursor
     667E 832A 
1615 6680 026C  22         ori   config,>8000          ; CONFIG register bit 0=1
     6682 8000 
1616 6684 10CF  14         jmp   mknum                 ; Convert number and display
1617               
1618               
1619               ***************************************************************
1620               * MKHEX - Convert hex word to string
1621               ***************************************************************
1622               *  BL   @MKHEX
1623               *  DATA P0,P1,P2
1624               *--------------------------------------------------------------
1625               *  P0 = Pointer to 16 bit word
1626               *  P1 = Pointer to string buffer
1627               *  P2 = Offset for ASCII digit
1628               *
1629               *  (CONFIG#0 = 1) = Display number at cursor YX
1630               ********|*****|*********************|**************************
1631 6686 C13B  30 mkhex   mov   *r11+,tmp0            ; Address of word
1632 6688 C83B  50         mov   *r11+,@waux3          ; Pointer to string buffer
     668A 8340 
1633 668C 0207  20         li    tmp3,waux1            ; We store the result in WAUX1 and WAUX2
     668E 833C 
1634 6690 04F7  30         clr   *tmp3+                ; Clear WAUX1
1635 6692 04D7  26         clr   *tmp3                 ; Clear WAUX2
1636 6694 0647  14         dect  tmp3                  ; Back to WAUX1
1637 6696 C114  26         mov   *tmp0,tmp0            ; Get word
1638               *--------------------------------------------------------------
1639               *    Convert nibbles to bytes (is in wrong order)
1640               *--------------------------------------------------------------
1641 6698 0205  20         li    tmp1,4
     669A 0004 
1642 669C C184  18 mkhex1  mov   tmp0,tmp2             ; Make work copy
1643 669E 0246  22         andi  tmp2,>000f            ; Only keep LSN
     66A0 000F 
1644 66A2 A19B  26         a     *r11,tmp2             ; Add ASCII-offset
1645 66A4 06C6  14 mkhex2  swpb  tmp2
1646 66A6 DDC6  32         movb  tmp2,*tmp3+           ; Save byte
1647 66A8 0944  56         srl   tmp0,4                ; Next nibble
1648 66AA 0605  14         dec   tmp1
1649 66AC 16F7  14         jne   mkhex1                ; Repeat until all nibbles processed
1650 66AE 024C  22         andi  config,>bfff          ; Reset bit 1 in config register
     66B0 BFFF 
1651               *--------------------------------------------------------------
1652               *    Build first 2 bytes in correct order
1653               *--------------------------------------------------------------
1654 66B2 C160  34         mov   @waux3,tmp1           ; Get pointer
     66B4 8340 
1655 66B6 04D5  26         clr   *tmp1                 ; Set length byte to 0
1656 66B8 0585  14         inc   tmp1                  ; Next byte, not word!
1657 66BA C120  34         mov   @waux2,tmp0
     66BC 833E 
1658 66BE 06C4  14         swpb  tmp0
1659 66C0 DD44  32         movb  tmp0,*tmp1+
1660 66C2 06C4  14         swpb  tmp0
1661 66C4 DD44  32         movb  tmp0,*tmp1+
1662               *--------------------------------------------------------------
1663               *    Set length byte
1664               *--------------------------------------------------------------
1665 66C6 C120  34         mov   @waux3,tmp0           ; Get start of string buffer
     66C8 8340 
1666 66CA D520  46         movb  @bd4,*tmp0            ; Set lengh byte to 4
     66CC 604E 
1667 66CE 05CB  14         inct  r11                   ; Skip Parameter P2
1668               *--------------------------------------------------------------
1669               *    Build last 2 bytes in correct order
1670               *--------------------------------------------------------------
1671 66D0 C120  34         mov   @waux1,tmp0
     66D2 833C 
1672 66D4 06C4  14         swpb  tmp0
1673 66D6 DD44  32         movb  tmp0,*tmp1+
1674 66D8 06C4  14         swpb  tmp0
1675 66DA DD44  32         movb  tmp0,*tmp1+
1676               *--------------------------------------------------------------
1677               *    Display hex number ?
1678               *--------------------------------------------------------------
1679 66DC 2320  38         coc   @wbit0,config         ; Check if 'display' bit is set
     66DE 6028 
1680 66E0 1301  14         jeq   mkhex3                ; Yes, so show at current YX position
1681 66E2 045B  20         b     *r11                  ; Exit
1682               *--------------------------------------------------------------
1683               *  Display hex number on screen at current YX position
1684               *--------------------------------------------------------------
1685 66E4 024C  22 mkhex3  andi  config,>7fff          ; Reset bit 0
     66E6 7FFF 
1686 66E8 C160  34         mov   @waux3,tmp1           ; Get Pointer to string
     66EA 8340 
1687 66EC 0460  28         b     @xutst0               ; Display string
     66EE 648A 
1688 66F0 0610     prefix  data  >0610                 ; Length byte + blank
1689               
1690               
1691               ***************************************************************
1692               * PUTHEX - Put 16 bit word on screen
1693               ***************************************************************
1694               *  BL   @PUTHEX
1695               *  DATA P0,P1,P2,P3
1696               *--------------------------------------------------------------
1697               *  P0 = YX position
1698               *  P1 = Pointer to 16 bit word
1699               *  P2 = Pointer to string buffer
1700               *  P3 = Offset for ASCII digit
1701               ********|*****|*********************|**************************
1702 66F2 C83B  50 puthex  mov   *r11+,@wyx            ; Set cursor
     66F4 832A 
1703 66F6 026C  22         ori   config,>8000          ; CONFIG register bit 0=1
     66F8 8000 
1704 66FA 10C5  14         jmp   mkhex                 ; Convert number and display
1705               
1706               
1707               ***************************************************************
1708               * VIEW - Viewport into virtual screen
1709               ***************************************************************
1710               *  BL   @VIEW
1711               *  DATA P0,P1,P2,P3,P4
1712               *--------------------------------------------------------------
1713               *  P0   = Pointer to RAM buffer
1714               *  P1   = Physical screen - upper left corner YX of viewport
1715               *  P2HB = Physical screen - Viewport height
1716               *  P2LB = Physical screen - Viewport width
1717               *  P3   = Virtual screen  - VRAM base address
1718               *  P4   = Virtual screen  - Number of columns
1719               *
1720               *  TMP0 must contain the YX offset in virtual screen
1721               *--------------------------------------------------------------
1722               * Memory usage
1723               * WAUX1 = Virtual screen VRAM base
1724               * WAUX2 = Virtual screen columns per row
1725               * WAUX3 = Virtual screen YX
1726               *
1727               * RAM buffer (offset)
1728               * 01  Physical screen VRAM base
1729               * 23  Physical screen columns per row
1730               * 45  Physical screen YX (viewport upper left corner)
1731               * 67  Height & width of viewport
1732               * 89  Return address
1733               ********|*****|*********************|**************************
1734 66FC C23B  30 view    mov   *r11+,tmp4            ; P0: Get pointer to RAM buffer
1735 66FE C620  46         mov   @wbase,*tmp4          ; RAM 01 - Save physical screen VRAM base
     6700 8328 
1736 6702 CA20  54         mov   @wcolmn,@2(tmp4)      ; RAM 23 - Save physical screen size (columns per row)
     6704 833A 
     6706 0002 
1737 6708 CA3B  50         mov   *r11+,@4(tmp4)        ; RAM 45 - P1: Get viewport upper left corner YX
     670A 0004 
1738 670C C1FB  30         mov   *r11+,tmp3            ;
1739 670E CA07  38         mov   tmp3,@6(tmp4)         ; RAM 67 - P2: Get viewport height & width
     6710 0006 
1740 6712 C83B  50         mov   *r11+,@waux1          ; P3: Get virtual screen VRAM base address
     6714 833C 
1741 6716 C83B  50         mov   *r11+,@waux2          ; P4: Get virtual screen size (columns per row)
     6718 833E 
1742 671A C804  38         mov   tmp0,@waux3           ; Get upper left corner YX in virtual screen
     671C 8340 
1743 671E CA0B  38         mov   r11,@8(tmp4)          ; RAM 89 - Store R11 for exit
     6720 0008 
1744 6722 0A1C  56         sla   config,1              ; \
1745 6724 091C  56         srl   config,1              ; / Clear CONFIG bits 0
1746 6726 0987  56         srl   tmp3,8                ; Row counter
1747               *--------------------------------------------------------------
1748               *    Set virtual screen dimension and position cursor
1749               *--------------------------------------------------------------
1750 6728 C820  54 view1   mov   @waux1,@wbase         ; Set virtual screen base
     672A 833C 
     672C 8328 
1751 672E C820  54         mov   @waux2,@wcolmn        ; Set virtual screen width
     6730 833E 
     6732 833A 
1752 6734 C820  54         mov   @waux3,@wyx           ; Set cursor in virtual screen
     6736 8340 
     6738 832A 
1753               *--------------------------------------------------------------
1754               *    Prepare for copying a single line
1755               *--------------------------------------------------------------
1756 673A 06A0  32 view2   bl    @yx2pnt               ; Get VRAM address in TMP0
     673C 62CC 
1757 673E C148  18         mov   tmp4,tmp1             ; RAM buffer + 10
1758 6740 0225  22         ai    tmp1,10               ;
     6742 000A 
1759 6744 C1A8  34         mov   @6(tmp4),tmp2         ; \ Get RAM buffer byte 1
     6746 0006 
1760 6748 0246  22         andi  tmp2,>00ff            ; / Clear MSB
     674A 00FF 
1761 674C 2B20  34         xor   @wbit0,config         ; Toggle bit 0
     674E 6028 
1762 6750 2720  38         czc   @wbit0,config         ; Bit 0=0 ?
     6752 6028 
1763 6754 130B  14         jeq   view4                 ; Yes! So copy from RAM to VRAM
1764               *--------------------------------------------------------------
1765               *    Copy line from VRAM to RAM
1766               *--------------------------------------------------------------
1767 6756 06A0  32 view3   bl    @xpyv2m               ; Copy block from VRAM (virtual screen) to RAM
     6758 614C 
1768 675A C818  46         mov   *tmp4,@wbase          ; Set physical screen base
     675C 8328 
1769 675E C828  54         mov   @2(tmp4),@wcolmn      ; Set physical screen columns per row
     6760 0002 
     6762 833A 
1770 6764 C828  54         mov   @4(tmp4),@wyx         ; Set cursor in physical screen
     6766 0004 
     6768 832A 
1771 676A 10E7  14         jmp   view2
1772               *--------------------------------------------------------------
1773               *    Copy line from RAM to VRAM
1774               *--------------------------------------------------------------
1775 676C 06A0  32 view4   bl    @xpym2v               ; Copy block to VRAM
     676E 6126 
1776 6770 BA20  54         ab    @bd1,@4(tmp4)         ; Physical screen Y=Y+1
     6772 604B 
     6774 0004 
1777 6776 B820  54         ab    @bd1,@waux3           ; Virtual screen  Y=Y+1
     6778 604B 
     677A 8340 
1778 677C 0607  14         dec   tmp3                  ; Update row counter
1779 677E 16D4  14         jne   view1                 ; Next line unless all rows process
1780               *--------------------------------------------------------------
1781               *    Exit
1782               *--------------------------------------------------------------
1783 6780 C2E8  34 viewz   mov   @8(tmp4),r11          ; \
     6782 0008 
1784 6784 045B  20         b     *r11                  ; / exit
1785               
1786               
1787               *//////////////////////////////////////////////////////////////
1788               *                            SOUND
1789               *//////////////////////////////////////////////////////////////
1790               
1791               ***************************************************************
1792               * MUTE - Mute all sound generators
1793               ***************************************************************
1794               *  BL  @MUTE
1795               *  Mute sound generators and clear sound pointer
1796               *
1797               *  BL  @MUTE2
1798               *  Mute sound generators without clearing sound pointer
1799               ********|*****|*********************|**************************
1800 6786 04E0  34 mute    clr   @wsdlst               ; Clear sound pointer
     6788 8334 
1801 678A 4320  34 mute2   szc   @wbit13,config        ; Turn off/pause sound player
     678C 6042 
1802 678E 0204  20         li    tmp0,muttab
     6790 67A0 
1803 6792 0205  20         li    tmp1,sound            ; Sound generator port >8400
     6794 8400 
1804 6796 D574  40         movb  *tmp0+,*tmp1          ; Generator 0
1805 6798 D574  40         movb  *tmp0+,*tmp1          ; Generator 1
1806 679A D574  40         movb  *tmp0+,*tmp1          ; Generator 2
1807 679C D554  38         movb  *tmp0,*tmp1           ; Generator 3
1808 679E 045B  20         b     *r11
1809 67A0 9FBF     muttab  byte  >9f,>bf,>df,>ff       ; Table for muting all generators
     67A2 DFFF 
1810               
1811               
1812               ***************************************************************
1813               * SDPREP - Prepare for playing sound
1814               ***************************************************************
1815               *  BL   @SDPREP
1816               *  DATA P0,P1
1817               *
1818               *  P0 = Address where tune is stored
1819               *  P1 = Option flags for sound player
1820               *--------------------------------------------------------------
1821               *  REMARKS
1822               *  Use the below equates for P1:
1823               *
1824               *  SDOPT1 => Tune is in CPU memory + loop
1825               *  SDOPT2 => Tune is in CPU memory
1826               *  SDOPT3 => Tune is in VRAM + loop
1827               *  SDOPT4 => Tune is in VRAM
1828               ********|*****|*********************|**************************
1829 67A4 C81B  46 sdprep  mov   *r11,@wsdlst          ; Set tune address
     67A6 8334 
1830 67A8 C83B  50         mov   *r11+,@wsdtmp         ; Set tune address in temp
     67AA 8336 
1831 67AC 024C  22         andi  r12,>fff8             ; Clear bits 13-14-15
     67AE FFF8 
1832 67B0 E33B  30         soc   *r11+,config          ; Set options
1833 67B2 D820  54         movb  @bd1,@r13lb           ; Set initial duration
     67B4 604B 
     67B6 831B 
1834 67B8 045B  20         b     *r11
1835               
1836               ***************************************************************
1837               * SDPLAY - Sound player for tune in VRAM or CPU memory
1838               ***************************************************************
1839               *  BL  @SDPLAY
1840               *--------------------------------------------------------------
1841               *  REMARKS
1842               *  Set config register bit13=0 to pause player.
1843               *  Set config register bit14=1 to repeat (or play next tune).
1844               ********|*****|*********************|**************************
1845 67BA 2320  38 sdplay  coc   @wbit13,config        ; Play tune ?
     67BC 6042 
1846 67BE 1301  14         jeq   sdpla1                ; Yes, play
1847 67C0 045B  20         b     *r11
1848               *--------------------------------------------------------------
1849               * Initialisation
1850               *--------------------------------------------------------------
1851 67C2 060D  14 sdpla1  dec   r13                   ; duration = duration - 1
1852 67C4 9820  54         cb    @r13lb,@bd0           ; R13LB == 0 ?
     67C6 831B 
     67C8 604A 
1853 67CA 1301  14         jeq   sdpla3                ; Play next note
1854 67CC 045B  20 sdpla2  b     *r11                  ; Note still busy, exit
1855 67CE 2320  38 sdpla3  coc   @wbit15,config        ; Play tune from CPU memory ?
     67D0 6046 
1856 67D2 131A  14         jeq   mmplay
1857               *--------------------------------------------------------------
1858               * Play tune from VDP memory
1859               *--------------------------------------------------------------
1860 67D4 C120  34 vdplay  mov   @wsdtmp,tmp0          ; Get tune address
     67D6 8336 
1861 67D8 06C4  14         swpb  tmp0
1862 67DA D804  38         movb  tmp0,@vdpa
     67DC 8C02 
1863 67DE 06C4  14         swpb  tmp0
1864 67E0 D804  38         movb  tmp0,@vdpa
     67E2 8C02 
1865 67E4 04C4  14         clr   tmp0
1866 67E6 D120  34         movb  @vdpr,tmp0            ; length = 0 (end of tune) ?
     67E8 8800 
1867 67EA 131E  14         jeq   sdexit                ; Yes. exit
1868 67EC 0984  56 vdpla1  srl   tmp0,8                ; Right justify length byte
1869 67EE A804  38         a     tmp0,@wsdtmp          ; Adjust for next table entry
     67F0 8336 
1870 67F2 D820  54 vdpla2  movb  @vdpr,@>8400          ; Feed byte to sound generator
     67F4 8800 
     67F6 8400 
1871 67F8 0604  14         dec   tmp0
1872 67FA 16FB  14         jne   vdpla2
1873 67FC D820  54         movb  @vdpr,@r13lb          ; Set duration counter
     67FE 8800 
     6800 831B 
1874 6802 05E0  34 vdpla3  inct  @wsdtmp               ; Adjust for next table entry, honour byte (1) + (n+1)
     6804 8336 
1875 6806 045B  20         b     *r11
1876               *--------------------------------------------------------------
1877               * Play tune from CPU memory
1878               *--------------------------------------------------------------
1879 6808 C120  34 mmplay  mov   @wsdtmp,tmp0
     680A 8336 
1880 680C D174  28         movb  *tmp0+,tmp1           ; length = 0 (end of tune) ?
1881 680E 130C  14         jeq   sdexit                ; Yes, exit
1882 6810 0985  56 mmpla1  srl   tmp1,8                ; Right justify length byte
1883 6812 A805  38         a     tmp1,@wsdtmp          ; Adjust for next table entry
     6814 8336 
1884 6816 D834  48 mmpla2  movb  *tmp0+,@>8400         ; Feed byte to sound generator
     6818 8400 
1885 681A 0605  14         dec   tmp1
1886 681C 16FC  14         jne   mmpla2
1887 681E D814  46         movb  *tmp0,@r13lb          ; Set duration counter
     6820 831B 
1888 6822 05E0  34         inct  @wsdtmp               ; Adjust for next table entry, honour byte (1) + (n+1)
     6824 8336 
1889 6826 045B  20         b     *r11
1890               *--------------------------------------------------------------
1891               * Exit. Check if tune must be looped
1892               *--------------------------------------------------------------
1893 6828 2320  38 sdexit  coc   @wbit14,config        ; Loop flag set ?
     682A 6044 
1894 682C 1607  14         jne   sdexi2                ; No, exit
1895 682E C820  54         mov   @wsdlst,@wsdtmp
     6830 8334 
     6832 8336 
1896 6834 D820  54         movb  @bd1,@r13lb           ; Set initial duration
     6836 604B 
     6838 831B 
1897 683A 045B  20 sdexi1  b     *r11                  ; Exit
1898 683C 024C  22 sdexi2  andi  config,>fff8          ; Reset music player
     683E FFF8 
1899 6840 045B  20         b     *r11                  ; Exit
1900               
1901               
1902               *//////////////////////////////////////////////////////////////
1903               *                            SPEECH
1904               *//////////////////////////////////////////////////////////////
1905               
1906               ***************************************************************
1907               * SPSTAT - Read status register byte from speech synthesizer
1908               ***************************************************************
1909               *  LI  TMP2,@>....
1910               *  B   @SPSTAT
1911               *--------------------------------------------------------------
1912               * REMARKS
1913               * Destroys R11 !
1914               *
1915               * Register usage
1916               * TMP0HB = Status byte read from speech synth
1917               * TMP1   = Temporary use  (scratchpad machine code)
1918               * TMP2   = Return address for this subroutine
1919               * R11    = Return address (scratchpad machine code)
1920               ********|*****|*********************|**************************
1921 6842 0204  20 spstat  li    tmp0,spchrd           ; (R4) = >9000
     6844 9000 
1922 6846 C820  54         mov   @spcode,@mcsprd       ; \
     6848 6086 
     684A 8322 
1923 684C C820  54         mov   @spcode+2,@mcsprd+2   ; / Load speech read code
     684E 6088 
     6850 8324 
1924 6852 020B  20         li    r11,spsta1            ; Return to SPSTA1
     6854 685A 
1925 6856 0460  28         b     @mcsprd               ; Run scratchpad code
     6858 8322 
1926 685A C820  54 spsta1  mov   @mccode,@mcsprd       ; \
     685C 6080 
     685E 8322 
1927 6860 C820  54         mov   @mccode+2,@mcsprd+2   ; / Restore tight loop code
     6862 6082 
     6864 8324 
1928 6866 0456  20         b     *tmp2                 ; Exit
1929               
1930               
1931               ***************************************************************
1932               * SPCONN - Check if speech synthesizer connected
1933               ***************************************************************
1934               * BL  @SPCONN
1935               *--------------------------------------------------------------
1936               * OUTPUT
1937               * TMP0HB = Byte read from speech synth
1938               *--------------------------------------------------------------
1939               * REMARKS
1940               * See Editor/Assembler manual, section 22.1.6 page 354.
1941               * Calls SPSTAT.
1942               *
1943               * Register usage
1944               * TMP0HB = Byte read from speech synth
1945               * TMP3   = Copy of R11
1946               * R12    = CONFIG register
1947               ********|*****|*********************|**************************
1948 6868 C1CB  18 spconn  mov   r11,tmp3              ; Save R11
1949               *--------------------------------------------------------------
1950               * Setup speech synthesizer memory address >0000
1951               *--------------------------------------------------------------
1952 686A 0204  20         li    tmp0,>4000            ; Load >40 (speech memory address command)
     686C 4000 
1953 686E 0205  20         li    tmp1,5                ; Process 5 nibbles in total
     6870 0005 
1954 6872 D804  38 spcon1  movb  tmp0,@spchwt          ; Write nibble >40 (5x)
     6874 9400 
1955 6876 0605  14         dec   tmp1
1956 6878 16FC  14         jne   spcon1
1957               *--------------------------------------------------------------
1958               * Read first byte from speech synthesizer memory address >0000
1959               *--------------------------------------------------------------
1960 687A 0204  20         li    tmp0,>1000
     687C 1000 
1961 687E D804  38         movb  tmp0,@spchwt          ; Load >10 (speech memory read command)
     6880 9400 
1962 6882 1000  14         nop                         ; \
1963 6884 1000  14         nop                         ; / 12 Microseconds delay
1964 6886 0206  20         li    tmp2,spcon2
     6888 688E 
1965 688A 0460  28         b     @spstat               ; Read status byte
     688C 6842 
1966               *--------------------------------------------------------------
1967               * Update status bit 10 in CONFIG register
1968               *--------------------------------------------------------------
1969 688E 0984  56 spcon2  srl   tmp0,8                ; MSB to LSB
1970 6890 0284  22         ci    tmp0,>00aa            ; >aa means speech found
     6892 00AA 
1971 6894 1603  14         jne   spcon3
1972 6896 026C  22         ori   config,>0020          ; Set config bit10=1
     6898 0020 
1973 689A 1002  14         jmp   spcon4
1974 689C 024C  22 spcon3  andi  config,>ffdf          ; Set config bit10=0
     689E FFDF 
1975 68A0 0457  20 spcon4  b     *tmp3                 ; Exit
1976               
1977               ***************************************************************
1978               * SPPREP - Prepare for playing speech
1979               ***************************************************************
1980               *  BL   @SPPREP
1981               *  DATA P0,P1
1982               *
1983               *  P0 = Address of LPC data for external voice
1984               *       or index of word to speak if resident voice
1985               *  P1 = Option flags for speech player
1986               *--------------------------------------------------------------
1987               *  REMARKS
1988               *  Use the below equates for P1:
1989               *
1990               *  SPOPT1  => External voice
1991               *  SPOPT2  => Resident voice
1992               ********|*****|*********************|**************************
1993 68A2 C83B  50 spprep  mov   *r11+,@wspeak         ; Set speech address
     68A4 8338 
1994 68A6 024C  22         andi  r12,>e3ff             ; Clear bits 3-4-5
     68A8 E3FF 
1995 68AA E33B  30         soc   *r11+,config          ; Set options
1996 68AC 045B  20         b     *r11
1997               
1998               ***************************************************************
1999               * SPPLAY - Speech player
2000               ***************************************************************
2001               * BL  @SPPLAY
2002               *--------------------------------------------------------------
2003               * Register usage
2004               * TMP3   = Copy of R11
2005               * R12    = CONFIG register
2006               ********|*****|*********************|**************************
2007 68AE 2720  38 spplay  czc   @wbit3,config         ; Player off ?
     68B0 602E 
2008 68B2 1332  14         jeq   spplaz                ; Yes, exit
2009 68B4 C1CB  18 sppla1  mov   r11,tmp3              ; Save R11
2010 68B6 2320  38         coc   @tmp010,config        ; Is on/busy/external ?
     68B8 691A 
2011 68BA 1313  14         jeq   spkex3                ; Check FIFO buffer level
2012 68BC 2320  38         coc   @wbit5,config         ; Start speak external ?
     68BE 6032 
2013 68C0 1300  14         jeq   spkext                ; Yes, do it
2014               *--------------------------------------------------------------
2015               * Speak resident: ****
2016               *--------------------------------------------------------------
2017               *       NOT   YET
2018               *--------------------------------------------------------------
2019               * Speak external: Push LPC data to speech synthesizer
2020               *--------------------------------------------------------------
2021 68C2 C120  34 spkext  mov   @wspeak,tmp0
     68C4 8338 
2022 68C6 D834  48         movb  *tmp0+,@spchwt        ; Send byte to speech synth
     68C8 9400 
2023 68CA 1000  14         jmp   $+2                   ; Delay
2024 68CC 0206  20         li    tmp2,16
     68CE 0010 
2025 68D0 D834  48 spkex1  movb  *tmp0+,@spchwt        ; Send byte to speech synth
     68D2 9400 
2026 68D4 0606  14         dec   tmp2
2027 68D6 16FC  14         jne   spkex1
2028 68D8 026C  22         ori   config,>1800          ; bit 4=1 (busy) & bit 5=1 (external)
     68DA 1800 
2029 68DC C804  38         mov   tmp0,@wspeak          ; Update LPC pointer
     68DE 8338 
2030 68E0 101B  14         jmp   spplaz                ; Exit
2031               *--------------------------------------------------------------
2032               * Speak external: Check synth FIFO buffer level
2033               *--------------------------------------------------------------
2034 68E2 0206  20 spkex3  li    tmp2,spkex4           ; Set return address for SPSTAT
     68E4 68EA 
2035 68E6 0460  28         b     @spstat               ; Get speech FIFO buffer status
     68E8 6842 
2036 68EA 2120  38 spkex4  coc   @wh4000,tmp0          ; FIFO BL (buffer low) bit set ?
     68EC 602A 
2037 68EE 1301  14         jeq   spkex5                ; Yes, refill
2038 68F0 1013  14         jmp   spplaz                ; No, exit
2039               *--------------------------------------------------------------
2040               * Speak external: Refill synth with LPC data if FIFO buffer low
2041               *--------------------------------------------------------------
2042 68F2 C120  34 spkex5  mov   @wspeak,tmp0
     68F4 8338 
2043 68F6 0206  20         li    tmp2,8                ; Bytes to send to speech synth
     68F8 0008 
2044 68FA D174  28 spkex6  movb  *tmp0+,tmp1
2045 68FC D805  38         movb  tmp1,@spchwt          ; Send byte to speech synth
     68FE 9400 
2046 6900 0285  22         ci    tmp1,spkoff           ; Speak off marker found ?
     6902 FF00 
2047 6904 1305  14         jeq   spkex8
2048 6906 0606  14         dec   tmp2
2049 6908 16F8  14         jne   spkex6                ; Send next byte
2050 690A C804  38         mov   tmp0,@wspeak          ; Update LPC pointer
     690C 8338 
2051 690E 1004  14 spkex7  jmp   spplaz                ; Exit
2052               *--------------------------------------------------------------
2053               * Speak external: Done with speaking
2054               *--------------------------------------------------------------
2055 6910 4320  34 spkex8  szc   @tmp010,config        ; bit 3,4,5=0
     6912 691A 
2056 6914 04E0  34         clr   @wspeak               ; Reset pointer
     6916 8338 
2057 6918 0457  20 spplaz  b     *tmp3                 ; Exit
2058 691A 1C00     tmp010  data  >1c00                 ; Binary 0001110000000000
2059               
2060               
2061               *//////////////////////////////////////////////////////////////
2062               *                           KEYBOARD
2063               *//////////////////////////////////////////////////////////////
2064               
2065               ***************************************************************
2066               * VIRTKB - Read virtual keyboard and joysticks
2067               ***************************************************************
2068               *  BL @VIRTKB
2069               *--------------------------------------------------------------
2070               *  COLUMN     0     1  2  3  4  5    6   7
2071               *         +---------------------------------+------+
2072               *  ROW 7  |   =     .  ,  M  N  /   JS1 JS2 | Fire |
2073               *  ROW 6  | SPACE   L  K  J  H  :;  JS1 JS2 | Left |
2074               *  ROW 5  | ENTER   O  I  U  Y  P   JS1 JS2 | Right|
2075               *  ROW 4  |         9  8  7  6  0   JS1 JS2 | Down |
2076               *  ROW 3  | FCTN    2  3  4  5  1   JS1 JS2 | Up   |
2077               *  ROW 2  | SHIFT   S  D  F  G  A           +------|
2078               *  ROW 1  | CTRL    W  E  R  T  Q                  |
2079               *  ROW 0  |         X  C  V  B  Z                  |
2080               *         +----------------------------------------+
2081               *  See MG smart programmer 1986
2082               *  September/Page 15 and November/Page 6
2083               *  Also see virtual keyboard status for bits to check
2084               *--------------------------------------------------------------
2085               *  Register usage
2086               *  TMP0     Keyboard matrix column to process
2087               *  TMP1MSB  Keyboard matrix 8 bits of 1 column
2088               *  TMP2     Virtual keyboard flags
2089               *  TMP3     Address of entry in mapping table
2090               *  TMP4     Copy of R12 (CONFIG REGISTER)
2091               *  R12      CRU communication
2092               ********|*****|*********************|**************************
2093 691C 4320  34 virtkb  szc   @wbit11,config        ; Reset ANY key
     691E 603E 
2094 6920 C20C  18         mov   config,tmp4           ; Save R12 (CONFIG REGISTER)
2095 6922 04C4  14         clr   tmp0                  ; Value in MSB! Start with column 0
2096 6924 04C6  14         clr   tmp2                  ; Erase virtual keyboard flags
2097 6926 0207  20         li    tmp3,kbmap0           ; Start with column 0
     6928 6998 
2098               *--------------------------------------------------------------
2099               * Check alpha lock key
2100               *-------@-----@---------------------@--------------------------
2101 692A 04CC  14         clr   r12
2102 692C 1E15  20         sbz   >0015                 ; Set P5
2103 692E 1F07  20         tb    7
2104 6930 1302  14         jeq   virtk1
2105 6932 0206  20         li    tmp2,kalpha           ; Alpha lock key down
     6934 8000 
2106               *--------------------------------------------------------------
2107               * Scan keyboard matrix
2108               *-------@-----@---------------------@--------------------------
2109 6936 1D15  20 virtk1  sbo   >0015                 ; Reset P5
2110 6938 020C  20         li    r12,>0024             ; Scan full 8x8 keyboard matrix. R12 is used by LDCR
     693A 0024 
2111 693C 30C4  56         ldcr  tmp0,3                ; Set keyboard column with a value from 0-7 (3=3 bits)
2112 693E 020C  20         li    r12,>0006             ; Load CRU base for row. R12 required by STCR
     6940 0006 
2113 6942 0705  14         seto  tmp1                  ; >FFFF
2114 6944 3605  64         stcr  tmp1,8                ; Bring 8 row bits into MSB of TMP1
2115 6946 0545  14         inv   tmp1
2116 6948 1302  14         jeq   virtk2                ; >0000 ?
2117 694A E220  34         soc   @wbit11,tmp4          ; Set ANY key in copy of CONFIG register
     694C 603E 
2118               *--------------------------------------------------------------
2119               * Process column
2120               *-------@-----@---------------------@--------------------------
2121 694E 2177  34 virtk2  coc   *tmp3+,tmp1           ; Check bit mask
2122 6950 1601  14         jne   virtk3
2123 6952 E197  26         soc   *tmp3,tmp2            ; Set virtual keyboard flags
2124 6954 05C7  14 virtk3  inct  tmp3
2125 6956 8817  46         c     *tmp3,@kbeoc          ; End-of-column ?
     6958 69A4 
2126 695A 16F9  14         jne   virtk2                ; No, next entry
2127 695C 05C7  14         inct  tmp3
2128               *--------------------------------------------------------------
2129               * Prepare for next column
2130               *-------@-----@---------------------@--------------------------
2131 695E 0284  22 virtk4  ci    tmp0,>0700            ; Column 7 processed ?
     6960 0700 
2132 6962 1309  14         jeq   virtk6                ; Yes, exit
2133 6964 0284  22         ci    tmp0,>0200            ; Column 2 processed ?
     6966 0200 
2134 6968 1303  14         jeq   virtk5                ; Yes, skip
2135 696A 0224  22         ai    tmp0,>0100
     696C 0100 
2136 696E 10E3  14         jmp   virtk1
2137 6970 0204  20 virtk5  li    tmp0,>0500            ; Skip columns 3-4
     6972 0500 
2138 6974 10E0  14         jmp   virtk1
2139               *--------------------------------------------------------------
2140               * Exit
2141               *-------@-----@---------------------@--------------------------
2142 6976 C308  18 virtk6  mov   tmp4,config           ; Restore CONFIG register
2143 6978 C806  38         mov   tmp2,@wvrtkb          ; Save virtual keyboard flags
     697A 8332 
2144 697C 1601  14         jne   virtk7
2145 697E 045B  20         b     *r11                  ; Exit
2146 6980 0286  22 virtk7  ci    tmp2,>ffff            ; FCTN-QUIT pressed ?
     6982 FFFF 
2147 6984 1603  14         jne   virtk8                ; No
2148 6986 0701  14         seto  r1                    ; Set exit flag
2149 6988 0460  28         b     @runli1               ; Yes, reset computer
     698A 6C7A 
2150 698C 0286  22 virtk8  ci    tmp2,kalpha           ; Only alpha-lock pressed ?
     698E 8000 
2151 6990 1602  14         jne   virtk9
2152 6992 4320  34         szc   @wbit11,config        ; Yes, so reset ANY key
     6994 603E 
2153 6996 045B  20 virtk9  b     *r11                  ; Exit
2154               *--------------------------------------------------------------
2155               * Mapping table
2156               *-------@-----@---------------------@--------------------------
2157               *                                   ; Bit 01234567
2158 6998 1100     kbmap0  data  >1100,>ffff           ; >11 00010001  FCTN QUIT
     699A FFFF 
2159 699C 0200             data  >0200,k1fire          ; >02 00000010  spacebar
     699E 0020 
2160 69A0 0400             data  >0400,kenter          ; >04 00000100  enter
     69A2 4000 
2161 69A4 FFFF     kbeoc   data  >ffff
2162 69A6 0800     kbmap1  data  >0800,kback           ; >08 00001000  FCTN BACK
     69A8 1000 
2163 69AA 2000             data  >2000,k1lf            ; >20 00100000  S (arrow left)
     69AC 0200 
2164 69AE 8000             data  >8000,k1dn            ; >80 10000000  X (arrow down)
     69B0 0040 
2165 69B2 FFFF             data  >ffff
2166 69B4 0800     kbmap2  data  >0800,kredo           ; >08 00001000  FCTN REDO
     69B6 2000 
2167 69B8 2000             data  >2000,k1rg            ; >20 00100000  D (arrow right)
     69BA 0100 
2168 69BC 4000             data  >4000,k1up            ; >80 01000000  E (arrow up)
     69BE 0080 
2169 69C0 FFFF             data  >ffff
2170 69C2 0800     kbcol5  data  >0800,kpause          ; >08 00001000  P (pause)
     69C4 0800 
2171 69C6 8000             data  >8000,k1fire          ; >80 01000000  Q (fire)
     69C8 0020 
2172 69CA FFFF             data  >ffff
2173 69CC 0100     kbmap6  data  >0100,k1fire          ; >01 00000001  joystick 1 FIRE
     69CE 0020 
2174 69D0 0200             data  >0200,k1lf            ; >02 00000010  joystick 1 left
     69D2 0200 
2175 69D4 0400             data  >0400,k1rg            ; >04 00000100  joystick 1 right
     69D6 0100 
2176 69D8 0800             data  >0800,k1dn            ; >08 00001000  joystick 1 down
     69DA 0040 
2177 69DC 1000             data  >1000,k1up            ; >10 00010000  joystick 1 up
     69DE 0080 
2178 69E0 FFFF             data  >ffff
2179 69E2 0100     kbmap7  data  >0100,k2fire          ; >01 00000001  joystick 2 FIRE
     69E4 0001 
2180 69E6 0200             data  >0200,k2lf            ; >02 00000010  joystick 2 left
     69E8 0010 
2181 69EA 0400             data  >0400,k2rg            ; >04 00000100  joystick 2 right
     69EC 0008 
2182 69EE 0800             data  >0800,k2dn            ; >08 00001000  joystick 2 down
     69F0 0002 
2183 69F2 1000             data  >1000,k2up            ; >10 00010000  joystick 2 up
     69F4 0004 
2184 69F6 FFFF             data  >ffff
2185               
2186               ***************************************************************
2187               * REALKB - Scan keyboard in real mode
2188               ***************************************************************
2189               *  BL @REALKB
2190               *--------------------------------------------------------------
2191               *  Based on work done by Simon Koppelmann
2192               *  taken from the book "TMS9900 assembler auf dem TI-99/4A"
2193               ********|*****|*********************|**************************
2194 69F8 C10C  18 realkb  mov   r12,tmp0              ; Save R12 (CONFIG) in TMP0
2195 69FA 0244  22         andi  tmp0,>7fff            ; Reset bit 0 in saved CONFIG register
     69FC 7FFF 
2196 69FE 020C  20         li    r12,>0024
     6A00 0024 
2197 6A02 020F  20         li    r15,kbsmal            ; Default is KBSMAL table
     6A04 6A96 
2198 6A06 04C6  14         clr   tmp2
2199 6A08 30C6  56         ldcr  tmp2,>0003            ; Lower case by default
2200               *--------------------------------------------------------------
2201               * SHIFT key pressed ?
2202               *--------------------------------------------------------------
2203 6A0A 04CC  14         clr   r12
2204 6A0C 1F08  20         tb    >0008                 ; Shift-key ?
2205 6A0E 1302  14         jeq   realk1                ; No
2206 6A10 020F  20         li    r15,kbshft            ; Yes, use KBSHIFT table
     6A12 6AC6 
2207               *--------------------------------------------------------------
2208               * FCTN key pressed ?
2209               *--------------------------------------------------------------
2210 6A14 1F07  20 realk1  tb    >0007                 ; FNCTN-key ?
2211 6A16 1302  14         jeq   realk2                ; No
2212 6A18 020F  20         li    r15,kbfctn            ; Yes, use KBFCTN table
     6A1A 6AF6 
2213               *--------------------------------------------------------------
2214               * CTRL key pressed ?
2215               *--------------------------------------------------------------
2216 6A1C 1F09  20 realk2  tb    >0009                 ; CTRL-key ?
2217 6A1E 1302  14         jeq   realk3                ; No
2218 6A20 020F  20         li    r15,kbctrl            ; Yes, use KBCTRL table
     6A22 6B26 
2219               *--------------------------------------------------------------
2220               * ALPHA LOCK key down ?
2221               *--------------------------------------------------------------
2222 6A24 1E15  20 realk3  sbz   >0015                 ; Set P5
2223 6A26 1F07  20         tb    >0007                 ; ALPHA-Lock key ?
2224 6A28 1602  14         jne   realk4                ; No,  saved CONFIG register bit 0 = 0
2225 6A2A 0264  22         ori   tmp0,>8000            ; Yes, saved CONFIG register bit 0 = 1
     6A2C 8000 
2226               *--------------------------------------------------------------
2227               * Scan keyboard column
2228               *--------------------------------------------------------------
2229 6A2E 1D15  20 realk4  sbo   >0015                 ; Reset P5
2230 6A30 0206  20         li    tmp2,6                ; Bitcombination for CRU, column counter
     6A32 0006 
2231 6A34 0606  14 realk5  dec   tmp2
2232 6A36 020C  20         li    r12,>24               ; CRU address for P2-P4
     6A38 0024 
2233 6A3A 06C6  14         swpb  tmp2
2234 6A3C 30C6  56         ldcr  tmp2,3                ; Transfer bit combination
2235 6A3E 06C6  14         swpb  tmp2
2236 6A40 020C  20         li    r12,6                 ; CRU read address
     6A42 0006 
2237 6A44 3607  64         stcr  tmp3,8                ; Transfer 8 bits into R2HB
2238 6A46 0547  14         inv   tmp3                  ;
2239 6A48 0247  22         andi  tmp3,>ff00            ; Clear TMP3LB
     6A4A FF00 
2240               *--------------------------------------------------------------
2241               * Scan keyboard row
2242               *--------------------------------------------------------------
2243 6A4C 04C5  14         clr   tmp1                  ; Use TMP1 as row counter from now on
2244 6A4E 0A17  56 realk6  sla   tmp3,1                ; R2 bitcombinations scanned by shifting left.
2245 6A50 1807  14         joc   realk8                ; If no carry after 8 loops, then it means no key
2246 6A52 0585  14 realk7  inc   tmp1                  ; was pressed on that line.
2247 6A54 0285  22         ci    tmp1,8
     6A56 0008 
2248 6A58 1AFA  14         jl    realk6
2249 6A5A C186  18         mov   tmp2,tmp2             ; All 6 columns processed ?
2250 6A5C 1BEB  14         jh    realk5                ; No, next column
2251 6A5E 1017  14         jmp   realkz                ; Yes, exit
2252               *--------------------------------------------------------------
2253               * Check for match in data table
2254               *--------------------------------------------------------------
2255 6A60 C206  18 realk8  mov   tmp2,tmp4
2256 6A62 0A38  56         sla   tmp4,3                ; TMP4 = TMP2 * 8
2257 6A64 A205  18         a     tmp1,tmp4             ; TMP4 = TMP4 + TMP1
2258 6A66 A20F  18         a     r15,tmp4              ; TMP4 = TMP4 + base address of data table (R15)
2259 6A68 D618  38         movb  *tmp4,*tmp4           ; Is the byte on that address = >00 ?
2260 6A6A 13F3  14         jeq   realk7                ; Yes, then discard and continue scanning (FCTN, SHIFT, CTRL)
2261               *--------------------------------------------------------------
2262               * Determine ASCII value of key
2263               *--------------------------------------------------------------
2264 6A6C D198  26 realk9  movb  *tmp4,tmp2            ; Real keypress. It's safe to reuse TMP2 now
2265 6A6E 2120  38         coc   @wbit0,tmp0           ; ALPHA-Lock key pressed ?
     6A70 6028 
2266 6A72 1608  14         jne   realka                ; No, continue with KBCONT4
2267 6A74 9806  38         cb    tmp2,@kbsmal+42       ; Is ASCII of key pressed < 97 ('a') ?
     6A76 6AC0 
2268 6A78 1A05  14         jl    realka
2269 6A7A 9806  38         cb    tmp2,@kbsmal+40       ; and ASCII of key pressed > 122 ('z') ?
     6A7C 6ABE 
2270 6A7E 1B02  14         jh    realka                ; No, continue with REALKA
2271 6A80 0226  22         ai    tmp2,->2000           ; ASCII = ASCII - 32 (lowercase to uppercase!)
     6A82 E000 
2272 6A84 0986  56 realka  srl   tmp2,8                ; Right justify
2273 6A86 C806  38         mov   tmp2,@waux3           ; Store ASCII value of key in WAUX3
     6A88 8340 
2274 6A8A E120  34         soc   @wbit11,tmp0          ; Set ANYKEY flag in saved CONFIG register
     6A8C 603E 
2275 6A8E C304  18 realkz  mov   tmp0,r12              ; Restore CONFIG register
2276 6A90 020F  20         li    r15,vdpw              ; Setup VDP write address again after using R15 as temp storage
     6A92 8C00 
2277 6A94 045B  20         b     *r11                  ; Exit
2278               ********|*****|*********************|**************************
2279 6A96 FF00     kbsmal  data  >ff00,>0000,>ff0d,>203D
     6A98 0000 
     6A9A FF0D 
     6A9C 203D 
2280 6A9E ....             text  'xws29ol.'
2281 6AA6 ....             text  'ced38ik,'
2282 6AAE ....             text  'vrf47ujm'
2283 6AB6 ....             text  'btg56yhn'
2284 6ABE ....             text  'zqa10p;/'
2285 6AC6 FF00     kbshft  data  >ff00,>0000,>ff0d,>202B
     6AC8 0000 
     6ACA FF0D 
     6ACC 202B 
2286 6ACE ....             text  'XWS@(OL>'
2287 6AD6 ....             text  'CED#*IK<'
2288 6ADE ....             text  'VRF$&UJM'
2289 6AE6 ....             text  'BTG%^YHN'
2290 6AEE ....             text  'ZQA!)P:-'
2291 6AF6 FF00     kbfctn  data  >ff00,>0000,>ff0d,>2005
     6AF8 0000 
     6AFA FF0D 
     6AFC 2005 
2292 6AFE 0A7E             data  >0a7e,>0804,>0f27,>c2B9
     6B00 0804 
     6B02 0F27 
     6B04 C2B9 
2293 6B06 600B             data  >600b,>0907,>063f,>c1B8
     6B08 0907 
     6B0A 063F 
     6B0C C1B8 
2294 6B0E 7F5B             data  >7f5b,>7b02,>015f,>c0C3
     6B10 7B02 
     6B12 015F 
     6B14 C0C3 
2295 6B16 BE5D             data  >be5d,>7d0e,>0cc6,>bfC4
     6B18 7D0E 
     6B1A 0CC6 
     6B1C BFC4 
2296 6B1E 5CB9             data  >5cb9,>7c03,>bc22,>bdBA
     6B20 7C03 
     6B22 BC22 
     6B24 BDBA 
2297 6B26 FF00     kbctrl  data  >ff00,>0000,>ff0d,>209D
     6B28 0000 
     6B2A FF0D 
     6B2C 209D 
2298 6B2E 9897             data  >9897,>93b2,>9f8f,>8c9B
     6B30 93B2 
     6B32 9F8F 
     6B34 8C9B 
2299 6B36 8385             data  >8385,>84b3,>9e89,>8b80
     6B38 84B3 
     6B3A 9E89 
     6B3C 8B80 
2300 6B3E 9692             data  >9692,>86b4,>b795,>8a8D
     6B40 86B4 
     6B42 B795 
     6B44 8A8D 
2301 6B46 8294             data  >8294,>87b5,>b698,>888E
     6B48 87B5 
     6B4A B698 
     6B4C 888E 
2302 6B4E 9A91             data  >9a91,>81b1,>b090,>9cBB
     6B50 81B1 
     6B52 B090 
     6B54 9CBB 
2303               
2304               
2305               
2306               *//////////////////////////////////////////////////////////////
2307               *                            TIMERS
2308               *//////////////////////////////////////////////////////////////
2309               
2310               ***************************************************************
2311               * TMGR - X - Start Timer/Thread scheduler
2312               ***************************************************************
2313               *  B @TMGR
2314               *--------------------------------------------------------------
2315               *  REMARKS
2316               *  Timer/Thread scheduler. Normally called from MAIN.
2317               *  Don't forget to set BTIHI to highest slot in use.
2318               *
2319               *  Register usage in TMGR8 - TMGR11
2320               *  TMP0  = Pointer to timer table
2321               *  R10LB = Use as slot counter
2322               *  TMP2  = 2nd word of slot data
2323               *  TMP3  = Address of routine to call
2324               ********|*****|*********************|**************************
2325 6B56 0300  24 tmgr    limi  0                     ; No interrupt processing
     6B58 0000 
2326               *--------------------------------------------------------------
2327               * Read VDP status register
2328               *--------------------------------------------------------------
2329 6B5A D120  34 tmgr1   movb  @vdps,tmp0            ; Get VDP status register
     6B5C 8802 
2330 6B5E D344  18         movb  tmp0,r13              ; Save copy of VDP status register in R13
2331 6B60 2120  38         coc   @wbit0,tmp0           ; Interupt flag set ?
     6B62 6028 
2332 6B64 1316  14         jeq   tmgr4                 ; Yes, process slots 0..n
2333               *--------------------------------------------------------------
2334               * Run speech player
2335               *--------------------------------------------------------------
2336 6B66 2320  38         coc   @wbit3,config         ; Speech player on ?
     6B68 602E 
2337 6B6A 1602  14         jne   tmgr2
2338 6B6C 06A0  32         bl    @sppla1               ; Run speech player
     6B6E 68B4 
2339               *--------------------------------------------------------------
2340               * Run kernel thread
2341               *--------------------------------------------------------------
2342 6B70 2320  38 tmgr2   coc   @wbit8,config         ; Kernel thread blocked ?
     6B72 6038 
2343 6B74 1305  14         jeq   tmgr3                 ; Yes, skip to user hook
2344 6B76 2320  38         coc   @wbit9,config         ; Kernel thread enabled ?
     6B78 603A 
2345 6B7A 1602  14         jne   tmgr3                 ; No, skip to user hook
2346 6B7C 0460  28         b     @kernel               ; Run kernel thread
     6B7E 6C22 
2347               *--------------------------------------------------------------
2348               * Run user hook
2349               *--------------------------------------------------------------
2350 6B80 2320  38 tmgr3   coc   @wbit6,config         ; User hook blocked ?
     6B82 6034 
2351 6B84 13EA  14         jeq   tmgr1
2352 6B86 2320  38         coc   @wbit7,config         ; User hook enabled ?
     6B88 6036 
2353 6B8A 16E7  14         jne   tmgr1
2354 6B8C C120  34         mov   @wtiusr,tmp0
     6B8E 832E 
2355 6B90 0454  20         b     *tmp0                 ; Run user hook
2356               *--------------------------------------------------------------
2357               * Do some internal housekeeping
2358               *--------------------------------------------------------------
2359 6B92 4320  34 tmgr4   szc   @tmdat,config         ; Unblock kernel thread and user hook
     6B94 6BF4 
2360 6B96 C10A  18         mov   r10,tmp0
2361 6B98 0244  22         andi  tmp0,>00ff            ; Clear HI byte
     6B9A 00FF 
2362 6B9C 2320  38         coc   @wbit2,config         ; PAL flag set ?
     6B9E 602C 
2363 6BA0 1303  14         jeq   tmgr5
2364 6BA2 0284  22         ci    tmp0,60               ; 1 second reached ?
     6BA4 003C 
2365 6BA6 1002  14         jmp   tmgr6
2366 6BA8 0284  22 tmgr5   ci    tmp0,50
     6BAA 0032 
2367 6BAC 1101  14 tmgr6   jlt   tmgr7                 ; No, continue
2368 6BAE 1001  14         jmp   tmgr8
2369 6BB0 058A  14 tmgr7   inc   r10                   ; Increase tick counter
2370               *--------------------------------------------------------------
2371               * Loop over slots
2372               *--------------------------------------------------------------
2373 6BB2 C120  34 tmgr8   mov   @wtitab,tmp0          ; Pointer to timer table
     6BB4 832C 
2374 6BB6 024A  22         andi  r10,>ff00             ; Use R10LB as slot counter. Reset.
     6BB8 FF00 
2375 6BBA C1D4  26 tmgr9   mov   *tmp0,tmp3            ; Is slot empty ?
2376 6BBC 1316  14         jeq   tmgr11                ; Yes, get next slot
2377               *--------------------------------------------------------------
2378               *  Check if slot should be executed
2379               *--------------------------------------------------------------
2380 6BBE 05C4  14         inct  tmp0                  ; Second word of slot data
2381 6BC0 0594  26         inc   *tmp0                 ; Update tick count in slot
2382 6BC2 C194  26         mov   *tmp0,tmp2            ; Get second word of slot data
2383 6BC4 9820  54         cb    @tmp2hb,@tmp2lb       ; Slot target count = Slot internal counter ?
     6BC6 830C 
     6BC8 830D 
2384 6BCA 1608  14         jne   tmgr10                ; No, get next slot
2385 6BCC 0246  22         andi  tmp2,>ff00            ; Clear internal counter
     6BCE FF00 
2386 6BD0 C506  30         mov   tmp2,*tmp0            ; Update timer table
2387               *--------------------------------------------------------------
2388               *  Run slot, we only need TMP0 to survive
2389               *--------------------------------------------------------------
2390 6BD2 C804  38         mov   tmp0,@wtitmp          ; Save TMP0
     6BD4 8330 
2391 6BD6 0697  24         bl    *tmp3                 ; Call routine in slot
2392 6BD8 C120  34 slotok  mov   @wtitmp,tmp0          ; Restore TMP0
     6BDA 8330 
2393               
2394               *--------------------------------------------------------------
2395               *  Prepare for next slot
2396               *--------------------------------------------------------------
2397 6BDC 058A  14 tmgr10  inc   r10                   ; Next slot
2398 6BDE 9820  54         cb    @r10lb,@btihi         ; Last slot done ?
     6BE0 8315 
     6BE2 8314 
2399 6BE4 1504  14         jgt   tmgr12                ; yes, Wait for next VDP interrupt
2400 6BE6 05C4  14         inct  tmp0                  ; Offset for next slot
2401 6BE8 10E8  14         jmp   tmgr9                 ; Process next slot
2402 6BEA 05C4  14 tmgr11  inct  tmp0                  ; Skip 2nd word of slot data
2403 6BEC 10F7  14         jmp   tmgr10                ; Process next slot
2404 6BEE 024A  22 tmgr12  andi  r10,>ff00             ; Use R10LB as tick counter. Reset.
     6BF0 FF00 
2405 6BF2 10B3  14         jmp   tmgr1
2406 6BF4 0280     tmdat   data  >0280                 ; Bit 8 (kernel thread) and bit 6 (user hook)
2407               
2408               
2409               ***************************************************************
2410               * MKSLOT - Allocate timer slot(s)
2411               ***************************************************************
2412               *  BL    @MKSLOT
2413               *  BYTE  P0HB,P0LB
2414               *  DATA  P1
2415               *  ....
2416               *  DATA  EOL                        ; End-of-list
2417               *--------------------------------------------------------------
2418               *  P0 = Slot number, target count
2419               *  P1 = Subroutine to call via BL @xxxx if slot is fired
2420               ********|*****|*********************|**************************
2421 6BF6 C13B  30 mkslot  mov   *r11+,tmp0
2422 6BF8 C17B  30         mov   *r11+,tmp1
2423               *--------------------------------------------------------------
2424               *  Calculate address of slot
2425               *--------------------------------------------------------------
2426 6BFA C184  18         mov   tmp0,tmp2
2427 6BFC 0966  56         srl   tmp2,6                ; Right align & TMP2 = TMP2 * 4
2428 6BFE A1A0  34         a     @wtitab,tmp2          ; Add table base
     6C00 832C 
2429               *--------------------------------------------------------------
2430               *  Add slot to table
2431               *--------------------------------------------------------------
2432 6C02 CD85  34         mov   tmp1,*tmp2+           ; Store address of subroutine
2433 6C04 0A84  56         sla   tmp0,8                ; Get rid of slot number
2434 6C06 C584  30         mov   tmp0,*tmp2            ; Store target count and reset tick count
2435               *--------------------------------------------------------------
2436               *  Check for end of list
2437               *--------------------------------------------------------------
2438 6C08 881B  46         c     *r11,@whffff          ; End of list ?
     6C0A 6048 
2439 6C0C 1301  14         jeq   mkslo1                ; Yes, exit
2440 6C0E 10F3  14         jmp   mkslot                ; Process next entry
2441               *--------------------------------------------------------------
2442               *  Exit
2443               *--------------------------------------------------------------
2444 6C10 05CB  14 mkslo1  inct  r11
2445 6C12 045B  20         b     *r11                  ; Exit
2446               
2447               
2448               ***************************************************************
2449               * CLSLOT - Clear single timer slot
2450               ***************************************************************
2451               *  BL    @CLSLOT
2452               *  DATA  P0
2453               *--------------------------------------------------------------
2454               *  P0 = Slot number
2455               ********|*****|*********************|**************************
2456 6C14 C13B  30 clslot  mov   *r11+,tmp0
2457 6C16 0A24  56 xlslot  sla   tmp0,2                ; TMP0 = TMP0*4
2458 6C18 A120  34         a     @wtitab,tmp0          ; Add table base
     6C1A 832C 
2459 6C1C 04F4  30         clr   *tmp0+                ; Clear 1st word of slot
2460 6C1E 04D4  26         clr   *tmp0                 ; Clear 2nd word of slot
2461 6C20 045B  20         b     *r11                  ; Exit
2462               
2463               
2464               ***************************************************************
2465               * KERNEL - The kernel thread
2466               *--------------------------------------------------------------
2467               *  REMARKS
2468               *  You shouldn't call the kernel thread manually.
2469               *  Instead control it via the CONFIG register.
2470               ********|*****|*********************|**************************
2471 6C22 E320  34 kernel  soc   @wbit8,config         ; Block kernel thread
     6C24 6038 
2472 6C26 2320  38         coc   @wbit13,config        ; Sound player on ?
     6C28 6042 
2473 6C2A 1602  14         jne   kerne1
2474 6C2C 06A0  32         bl    @sdpla1               ; Run sound player
     6C2E 67C2 
2475 6C30 06A0  32 kerne1  bl    @virtkb               ; Scan virtual keyboard
     6C32 691C 
2476 6C34 2320  38         coc   @wbit12,config        ; Keyboard mode real ?
     6C36 6040 
2477 6C38 1602  14         jne   kernez                ; No, exit
2478 6C3A 06A0  32         bl    @realkb               ; Scan full keyboard
     6C3C 69F8 
2479 6C3E 0460  28 kernez  b     @tmgr3                ; Exit
     6C40 6B80 
2480               
2481               
2482               
2483               ***************************************************************
2484               * MKHOOK - Allocate user hook
2485               ***************************************************************
2486               *  BL    @MKHOOK
2487               *  DATA  P0
2488               *--------------------------------------------------------------
2489               *  P0 = Address of user hook
2490               *--------------------------------------------------------------
2491               *  REMARKS
2492               *  The user hook gets executed after the kernel thread.
2493               *  The user hook must always exit with "B @HOOKOK"
2494               ********|*****|*********************|**************************
2495 6C42 C83B  50 mkhook  mov   *r11+,@wtiusr         ; Set user hook address
     6C44 832E 
2496 6C46 026C  22         ori   config,enusr          ; Enable user hook
     6C48 0100 
2497 6C4A 045B  20 mkhoo1  b     *r11                  ; Return
2498      6B5A     hookok  equ   tmgr1                 ; Exit point for user hook
2499               
2500               
2501               
2502               *//////////////////////////////////////////////////////////////
2503               *                       MISC FUNCTIONS
2504               *//////////////////////////////////////////////////////////////
2505               
2506               ***************************************************************
2507               * POPR. - Pop registers & return to caller
2508               ***************************************************************
2509               *  B  @POPRG.
2510               *--------------------------------------------------------------
2511               *  REMARKS
2512               *  R11 must be at stack bottom
2513               ********|*****|*********************|**************************
2514 6C4C C0F9  30 popr3   mov   *stack+,r3
2515 6C4E C0B9  30 popr2   mov   *stack+,r2
2516 6C50 C079  30 popr1   mov   *stack+,r1
2517 6C52 C039  30 popr0   mov   *stack+,r0
2518 6C54 C2F9  30 poprt   mov   *stack+,r11
2519 6C56 045B  20         b     *r11
2520               
2521               
2522               ***************************************************************
2523               * RND - Generate random number
2524               ***************************************************************
2525               *  BL   @RND
2526               *  DATA P0,P1
2527               *--------------------------------------------------------------
2528               *  P0 = Highest random number allowed
2529               *  P1 = Address of random seed
2530               *--------------------------------------------------------------
2531               *  BL   @RNDX
2532               *
2533               *  TMP0 = Highest random number allowed
2534               *  TMP3 = Address of random seed
2535               *--------------------------------------------------------------
2536               *  OUTPUT
2537               *  TMP0 = The generated random number
2538               ********|*****|*********************|**************************
2539 6C58 C13B  30 rnd     mov   *r11+,tmp0            ; Highest number allowed
2540 6C5A C1FB  30         mov   *r11+,tmp3            ; Get address of random seed
2541 6C5C 04C5  14 rndx    clr   tmp1
2542 6C5E C197  26         mov   *tmp3,tmp2            ; Get random seed
2543 6C60 1601  14         jne   rnd1
2544 6C62 0586  14         inc   tmp2                  ; May not be zero
2545 6C64 0916  56 rnd1    srl   tmp2,1
2546 6C66 1702  14         jnc   rnd2
2547 6C68 29A0  34         xor   @rnddat,tmp2
     6C6A 6C74 
2548 6C6C C5C6  30 rnd2    mov   tmp2,*tmp3            ; Store new random seed
2549 6C6E 3D44  128         div   tmp0,tmp1
2550 6C70 C106  18         mov   tmp2,tmp0
2551 6C72 045B  20         b     *r11                  ; Exit
2552 6C74 B400     rnddat  data  >0b400                ; The magic number
2553               
2554               
2555               *//////////////////////////////////////////////////////////////
2556               *                    RUNLIB INITIALISATION
2557               *//////////////////////////////////////////////////////////////
2558               
2559               ***************************************************************
2560               *  RUNLIB - Runtime library initalisation
2561               ***************************************************************
2562               *  B  @RUNLIB
2563               *--------------------------------------------------------------
2564               *  REMARKS
2565               *  If R1 in WS1 equals >FFFF we return to the TI title screen
2566               *  after clearing scratchpad memory.
2567               *  Use 'B @RUNLI1' to exit your program.
2568               ********|*****|*********************|**************************
2569 6C76 04E0  34 runlib  clr   @>8302                ; Reset exit flag (R1 in workspace WS1!)
     6C78 8302 
2570               *--------------------------------------------------------------
2571               * Alternative entry point
2572               *--------------------------------------------------------------
2573 6C7A 0300  24 runli1  limi  0                     ; Turn off interrupts
     6C7C 0000 
2574 6C7E 02E0  18         lwpi  ws1                   ; Activate workspace 1
     6C80 8300 
2575 6C82 C0E0  34         mov   @>83c0,r3             ; Get random seed from OS monitor
     6C84 83C0 
2576               
2577               *--------------------------------------------------------------
2578               * Clear scratch-pad memory from R4 upwards
2579               *--------------------------------------------------------------
2580 6C86 0202  20 runli2  li    r2,>8308
     6C88 8308 
2581 6C8A 04F2  30 runli3  clr   *r2+                  ; Clear scratchpad >8306->83FF
2582 6C8C 0282  22         ci    r2,>8400
     6C8E 8400 
2583 6C90 16FC  14         jne   runli3
2584               *--------------------------------------------------------------
2585               * Exit to TI-99/4A title screen ?
2586               *--------------------------------------------------------------
2587 6C92 0281  22         ci    r1,>ffff              ; Exit flag set ?
     6C94 FFFF 
2588 6C96 1602  14         jne   runli4                ; No, continue
2589 6C98 0420  54         blwp  @0                    ; Yes, bye bye
     6C9A 0000 
2590               *--------------------------------------------------------------
2591               * Determine if VDP is PAL or NTSC
2592               *--------------------------------------------------------------
2593 6C9C C803  38 runli4  mov   r3,@waux1             ; Store random seed
     6C9E 833C 
2594 6CA0 04C1  14         clr   r1                    ; Reset counter
2595 6CA2 0202  20         li    r2,10                 ; We test 10 times
     6CA4 000A 
2596 6CA6 C0E0  34 runli5  mov   @vdps,r3
     6CA8 8802 
2597 6CAA 20E0  38         coc   @wbit0,r3             ; Interupt flag set ?
     6CAC 6028 
2598 6CAE 1302  14         jeq   runli6
2599 6CB0 0581  14         inc   r1                    ; Increase counter
2600 6CB2 10F9  14         jmp   runli5
2601 6CB4 0602  14 runli6  dec   r2                    ; Next test
2602 6CB6 16F7  14         jne   runli5
2603 6CB8 0281  22         ci    r1,>1250              ; Max for NTSC reached ?
     6CBA 1250 
2604 6CBC 1202  14         jle   runli7                ; No, so it must be NTSC
2605 6CBE 026C  22         ori   config,palon          ; Yes, it must be PAL, set flag
     6CC0 2000 
2606               *--------------------------------------------------------------
2607               * Prepare tight loop
2608               *--------------------------------------------------------------
2609 6CC2 06A0  32 runli7  bl    @cpym2m
     6CC4 60D6 
2610 6CC6 6080             data  mccode,mcloop+2,6     ; Copy machine code to scratchpad
     6CC8 8322 
     6CCA 0006 
2611               *--------------------------------------------------------------
2612               * Determine TI-99/4(A) operating system
2613               *--------------------------------------------------------------
2614 6CCC 06A0  32         bl    @cpyg2m               ; Read GROM >0480 into TMP0
     6CCE 6168 
2615 6CD0 0480             data  >0480,r3hb,2
     6CD2 8306 
     6CD4 0002 
2616 6CD6 8803  38         c     r3,@tmp004            ; Check for TI-99/4
     6CD8 6D34 
2617 6CDA 1602  14         jne   runli9
2618               *--------------------------------------------------------------
2619               *    It's a TI-99/4 .... PANIC !
2620               *--------------------------------------------------------------
2621 6CDC 0701  14 runli8  seto  r1                    ; Set reset flag
2622 6CDE 10CD  14         jmp   runli1                ; Bye bye
2623               *--------------------------------------------------------------
2624               * Initialize registers, memory, ...
2625               *--------------------------------------------------------------
2626 6CE0 04C1  14 runli9  clr   r1
2627 6CE2 04C2  14         clr   r2
2628 6CE4 04C3  14         clr   r3
2629 6CE6 0209  20         li    stack,>8400           ; Set stack
     6CE8 8400 
2630 6CEA 020F  20         li    r15,vdpw              ; Set VDP write address
     6CEC 8C00 
2631 6CEE 06A0  32         bl    @mute                 ; Mute sound generators
     6CF0 6786 
2632               *--------------------------------------------------------------
2633               * Setup video memory
2634               *--------------------------------------------------------------
2635 6CF2 06A0  32         bl    @filv
     6CF4 60AE 
2636 6CF6 0000             data  >0000,>00,16000       ; Clear VDP memory
     6CF8 0000 
     6CFA 3E80 
2637 6CFC 06A0  32         bl    @filv
     6CFE 60AE 
2638 6D00 0380             data  >0380,spfclr,16       ; Load color table
     6D02 00F5 
     6D04 0010 
2639               *--------------------------------------------------------------
2640               * Check if there is a F18A present
2641               *--------------------------------------------------------------
2642 6D06 06A0  32         bl    @f18unl               ; Unlock the F18A
     6D08 6372 
2643 6D0A 06A0  32         bl    @f18chk               ; Check if F18A is there
     6D0C 6392 
2644 6D0E 06A0  32         bl    @f18lck               ; Lock the F18A again
     6D10 6388 
2645               *--------------------------------------------------------------
2646               * Check if there is a speech synthesizer attached
2647               *--------------------------------------------------------------
2648 6D12 06A0  32         bl    @spconn
     6D14 6868 
2649               *--------------------------------------------------------------
2650               * Load video mode table & font
2651               *--------------------------------------------------------------
2652 6D16 06A0  32 runlic  bl    @vidtab               ; Load video mode table into VDP
     6D18 6234 
2653 6D1A 6056             data  spvmod                ; Equate selected video mode table
2654 6D1C 0204  20         li    tmp0,spfont           ; Get font option
     6D1E 000C 
2655 6D20 0544  14         inv   tmp0                  ; NOFONT (>FFFF) specified ?
2656 6D22 1304  14         jeq   runlid                ; Yes, skip it
2657 6D24 06A0  32         bl    @ldfnt
     6D26 63F8 
2658 6D28 0900             data  >0900,spfont          ; Load specified font
     6D2A 000C 
2659               *--------------------------------------------------------------
2660               * Branch to main program
2661               *--------------------------------------------------------------
2662 6D2C 026C  22 runlid  ori   config,enknl          ; Enable kernel thread
     6D2E 0040 
2663 6D30 0460  28         b     @main                 ; Give control to main program
     6D32 6D36 
2664 6D34 48FC     tmp004  data  >48fc                 ; TI-99/4   1979
**** **** ****     > test1.a99
0023               *--------------------------------------------------------------
0024               * SPECTRA2 startup options
0025               *--------------------------------------------------------------
0026      00F5     spfclr  equ   >F5                   ; Foreground/Background color for font.
0027      0001     spfbck  equ   >01                   ; Screen background color.
0028               *--------------------------------------------------------------
0029               * Variables
0030               *--------------------------------------------------------------
0031      8342     timers  equ   >8342                 ; Address of timer table (8 bytes)
0032      8350     fwvers  equ   >8350                 ; F18A Firmware version
0033      8352     rambuf  equ   >8352                 ; Work buffer
0034               ;--------------------------------------------------------------
0035               ; graphics mode 1 configuration (32x24)
0036               ;--------------------------------------------------------------
0037      6056     spvmod  equ   graph1                ; Video mode.   See VIDTAB for details.
0038      000C     spfont  equ   fnopt3                ; Font to load. See LDFONT for details.
0039               ***************************************************************
0040               * Main
0041               ********|*****|*********************|**************************
0042 6D36 2320  38 main    coc   @wbit1,config         ; CONFIG bit 1 set ?
     6D38 602A 
0043 6D3A 1302  14         jeq   main1                 ; Yes, we have a F18A
0044 6D3C 0420  54         blwp  @0                    ; No, return to title screen
     6D3E 0000 
0045               *--------------------------------------------------------------
0046               * Here we go
0047               *--------------------------------------------------------------
0048               *
0049 6D40 06A0  32 main1   bl    @f18unl               ; Unlock the beast
     6D42 6372 
0050 6D44 06A0  32         bl    @vidtab
     6D46 6234 
0051 6D48 606A             data  tx8024                ; 80x24 Video mode
0052 6D4A 06A0  32         bl    @putat
     6D4C 649A 
0053 6D4E 0A10             data  >0A10,hw
     6D50 6D56 
0054 6D52 0460  28         b     @kernel               ; FCTN-QUIT Handler
     6D54 6C22 
0055               *--------------------------------------------------------------
0056               * Data
0057               *--------------------------------------------------------------
0058 6D56 0C48     hw      byte  12
0059 6D57 ....             text  'Hello World!'
0060                       even
